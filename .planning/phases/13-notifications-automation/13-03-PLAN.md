# Plan 13-03: Notification Hooks

## Objective

Create React Query hooks for managing notifications, user preferences, and activity logging. These hooks provide the data layer for the notification center UI.

## Prerequisites

- Plan 13-01 complete (Notification Data Foundation)
- Plan 13-02 complete (Email Edge Function)

## Dependencies

- 13-01 (Notification types and constants)
- 13-02 (Email sending capability)

## Tasks

### Task 1: Create notification hooks
**File**: `apps/admin/src/hooks/use-notifications.ts`

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import type {
  Notification,
  NotificationType,
  CreateNotificationPayload,
  NotificationSummary,
} from '@/lib/types/notification'
import { sortNotifications, countUnreadByType } from '@/lib/helpers/notifications'

/**
 * Query key factory for notifications
 */
export const notificationKeys = {
  all: ['notifications'] as const,
  lists: () => [...notificationKeys.all, 'list'] as const,
  list: (filters: { unread?: boolean; type?: NotificationType }) =>
    [...notificationKeys.lists(), filters] as const,
  detail: (id: string) => [...notificationKeys.all, 'detail', id] as const,
  unreadCount: () => [...notificationKeys.all, 'unread-count'] as const,
  summary: () => [...notificationKeys.all, 'summary'] as const,
}

/**
 * Fetch notifications for current user
 */
async function fetchNotifications(params: {
  unread?: boolean
  type?: NotificationType
  limit?: number
}): Promise<Notification[]> {
  let query = supabase
    .from('notifications')
    .select('*')
    .order('created_at', { ascending: false })
    .limit(params.limit ?? 50)

  if (params.unread) {
    query = query.eq('is_read', false)
  }

  if (params.type) {
    query = query.eq('notification_type', params.type)
  }

  const { data, error } = await query

  if (error) throw error
  return sortNotifications(data ?? [])
}

/**
 * Hook: Get notifications list
 */
export function useNotifications(params: {
  unread?: boolean
  type?: NotificationType
  limit?: number
} = {}) {
  const { profile } = useAuthStore()

  return useQuery({
    queryKey: notificationKeys.list({ unread: params.unread, type: params.type }),
    queryFn: () => fetchNotifications(params),
    enabled: !!profile,
    staleTime: 30 * 1000, // 30 seconds
    refetchInterval: 60 * 1000, // Refetch every minute
  })
}

/**
 * Hook: Get unread notification count
 */
export function useUnreadNotificationCount() {
  const { profile } = useAuthStore()

  return useQuery({
    queryKey: notificationKeys.unreadCount(),
    queryFn: async () => {
      const { count, error } = await supabase
        .from('notifications')
        .select('*', { count: 'exact', head: true })
        .eq('is_read', false)

      if (error) throw error
      return count ?? 0
    },
    enabled: !!profile,
    staleTime: 15 * 1000, // 15 seconds
    refetchInterval: 30 * 1000, // Refetch every 30 seconds
  })
}

/**
 * Hook: Get notification summary for dashboard
 */
export function useNotificationSummary() {
  const { profile } = useAuthStore()

  return useQuery({
    queryKey: notificationKeys.summary(),
    queryFn: async (): Promise<NotificationSummary> => {
      const { data, error } = await supabase
        .from('notifications')
        .select('*')
        .eq('is_read', false)
        .order('created_at', { ascending: false })
        .limit(100)

      if (error) throw error

      const notifications = data ?? []
      const byType = countUnreadByType(notifications)

      return {
        total_unread: notifications.length,
        by_type: byType,
        recent: notifications.slice(0, 5),
      }
    },
    enabled: !!profile,
    staleTime: 30 * 1000,
  })
}

/**
 * Hook: Mark notification as read
 */
export function useMarkNotificationRead() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (notificationId: string) => {
      const { error } = await supabase
        .from('notifications')
        .update({
          is_read: true,
          read_at: new Date().toISOString(),
        })
        .eq('id', notificationId)

      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: notificationKeys.all })
    },
  })
}

/**
 * Hook: Mark all notifications as read
 */
export function useMarkAllNotificationsRead() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async () => {
      const { error } = await supabase
        .from('notifications')
        .update({
          is_read: true,
          read_at: new Date().toISOString(),
        })
        .eq('is_read', false)

      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: notificationKeys.all })
    },
  })
}

/**
 * Hook: Create notification
 */
export function useCreateNotification() {
  const queryClient = useQueryClient()
  const { profile } = useAuthStore()

  return useMutation({
    mutationFn: async (payload: CreateNotificationPayload) => {
      const { data, error } = await supabase
        .from('notifications')
        .insert({
          organization_id: profile?.organization_id,
          user_id: payload.user_id,
          title: payload.title,
          message: payload.message,
          notification_type: payload.notification_type,
          priority: payload.priority ?? 'medium',
          entity_type: payload.entity_type,
          entity_id: payload.entity_id,
          action_url: payload.action_url,
        })
        .select()
        .single()

      if (error) throw error
      return data
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: notificationKeys.all })
    },
  })
}

/**
 * Hook: Delete notification
 */
export function useDeleteNotification() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (notificationId: string) => {
      const { error } = await supabase
        .from('notifications')
        .delete()
        .eq('id', notificationId)

      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: notificationKeys.all })
    },
  })
}

/**
 * Hook: Delete all read notifications
 */
export function useClearReadNotifications() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async () => {
      const { error } = await supabase
        .from('notifications')
        .delete()
        .eq('is_read', true)

      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: notificationKeys.all })
    },
  })
}

/**
 * Real-time notification subscription
 */
export function useNotificationSubscription(
  onNewNotification: (notification: Notification) => void
) {
  const { profile } = useAuthStore()
  const queryClient = useQueryClient()

  // Set up real-time subscription
  const subscription = supabase
    .channel('notifications')
    .on(
      'postgres_changes',
      {
        event: 'INSERT',
        schema: 'public',
        table: 'notifications',
        filter: `user_id=eq.${profile?.id}`,
      },
      (payload) => {
        const notification = payload.new as Notification
        onNewNotification(notification)
        queryClient.invalidateQueries({ queryKey: notificationKeys.all })
      }
    )
    .subscribe()

  return () => {
    subscription.unsubscribe()
  }
}
```

**Verification**: File exists with ~200 lines of notification hooks

### Task 2: Create notification preferences hooks
**File**: `apps/admin/src/hooks/use-notification-preferences.ts`

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import type { NotificationPreferences } from '@/lib/types/notification'
import { DEFAULT_NOTIFICATION_PREFERENCES } from '@/lib/constants/notifications'

/**
 * Query key factory for preferences
 */
export const preferencesKeys = {
  all: ['notification-preferences'] as const,
  user: (userId: string) => [...preferencesKeys.all, userId] as const,
}

/**
 * Parse user settings JSONB to notification preferences
 */
function parsePreferences(settings: unknown): NotificationPreferences {
  const defaultPrefs = { ...DEFAULT_NOTIFICATION_PREFERENCES }

  if (!settings || typeof settings !== 'object') {
    return defaultPrefs
  }

  const s = settings as Record<string, unknown>
  const notifications = s.notifications as Record<string, boolean> | undefined

  if (notifications) {
    return {
      email: notifications.email ?? defaultPrefs.email,
      push: notifications.push ?? defaultPrefs.push,
      sms: notifications.sms ?? defaultPrefs.sms,
      inspection_reminders: notifications.inspection_reminders ?? defaultPrefs.inspection_reminders,
      work_order_updates: notifications.work_order_updates ?? defaultPrefs.work_order_updates,
      payment_alerts: notifications.payment_alerts ?? defaultPrefs.payment_alerts,
      daily_digest: notifications.daily_digest ?? defaultPrefs.daily_digest,
      weekly_summary: notifications.weekly_summary ?? defaultPrefs.weekly_summary,
    }
  }

  return defaultPrefs
}

/**
 * Hook: Get notification preferences
 */
export function useNotificationPreferences() {
  const { profile } = useAuthStore()

  return useQuery({
    queryKey: preferencesKeys.user(profile?.id ?? ''),
    queryFn: async (): Promise<NotificationPreferences> => {
      if (!profile?.id) {
        return DEFAULT_NOTIFICATION_PREFERENCES
      }

      const { data, error } = await supabase
        .from('users')
        .select('settings')
        .eq('id', profile.id)
        .single()

      if (error) throw error
      return parsePreferences(data?.settings)
    },
    enabled: !!profile?.id,
    staleTime: 5 * 60 * 1000, // 5 minutes
  })
}

/**
 * Hook: Update notification preferences
 */
export function useUpdateNotificationPreferences() {
  const { profile } = useAuthStore()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (preferences: Partial<NotificationPreferences>) => {
      if (!profile?.id) throw new Error('Not authenticated')

      // First get current settings
      const { data: currentData } = await supabase
        .from('users')
        .select('settings')
        .eq('id', profile.id)
        .single()

      const currentSettings = (currentData?.settings as Record<string, unknown>) ?? {}
      const currentNotifications = (currentSettings.notifications as Record<string, unknown>) ?? {}

      // Merge new preferences
      const updatedSettings = {
        ...currentSettings,
        notifications: {
          ...currentNotifications,
          ...preferences,
        },
      }

      const { error } = await supabase
        .from('users')
        .update({ settings: updatedSettings })
        .eq('id', profile.id)

      if (error) throw error
      return preferences
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: preferencesKeys.all })
    },
  })
}

/**
 * Hook: Toggle single preference
 */
export function useTogglePreference() {
  const updatePrefs = useUpdateNotificationPreferences()

  return {
    ...updatePrefs,
    toggle: async (key: keyof NotificationPreferences, currentValue: boolean) => {
      return updatePrefs.mutateAsync({ [key]: !currentValue })
    },
  }
}

/**
 * Hook: Reset preferences to default
 */
export function useResetPreferences() {
  const updatePrefs = useUpdateNotificationPreferences()

  return {
    ...updatePrefs,
    reset: async () => {
      return updatePrefs.mutateAsync(DEFAULT_NOTIFICATION_PREFERENCES)
    },
  }
}
```

**Verification**: File exists with ~120 lines of preference hooks

### Task 3: Create activity log hooks
**File**: `apps/admin/src/hooks/use-activity-log.ts`

```typescript
import { useQuery, useMutation, useQueryClient, useInfiniteQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import type {
  ActivityLogEntry,
  ActivityAction,
  ActivityEntityType,
} from '@/lib/types/notification'

/**
 * Query key factory for activity log
 */
export const activityKeys = {
  all: ['activity-log'] as const,
  lists: () => [...activityKeys.all, 'list'] as const,
  list: (filters: { entity_type?: string; user_id?: string }) =>
    [...activityKeys.lists(), filters] as const,
  entity: (entityType: string, entityId: string) =>
    [...activityKeys.all, 'entity', entityType, entityId] as const,
  recent: (limit?: number) => [...activityKeys.all, 'recent', limit] as const,
}

/**
 * Fetch activity log entries
 */
async function fetchActivityLog(params: {
  entity_type?: ActivityEntityType
  user_id?: string
  limit?: number
  offset?: number
}): Promise<ActivityLogEntry[]> {
  let query = supabase
    .from('activity_log')
    .select(`
      *,
      user:users(first_name, last_name)
    `)
    .order('created_at', { ascending: false })
    .range(params.offset ?? 0, (params.offset ?? 0) + (params.limit ?? 50) - 1)

  if (params.entity_type) {
    query = query.eq('entity_type', params.entity_type)
  }

  if (params.user_id) {
    query = query.eq('user_id', params.user_id)
  }

  const { data, error } = await query

  if (error) throw error

  return (data ?? []).map((entry) => {
    const user = entry.user as { first_name?: string; last_name?: string } | null
    return {
      id: entry.id,
      user_id: entry.user_id,
      user_name: user
        ? `${user.first_name ?? ''} ${user.last_name ?? ''}`.trim() || 'Unknown'
        : 'System',
      action: entry.action as ActivityAction,
      entity_type: entry.entity_type as ActivityEntityType,
      entity_id: entry.entity_id,
      entity_name: entry.entity_name ?? undefined,
      changes: entry.changes as Record<string, { old: unknown; new: unknown }> | undefined,
      metadata: entry.metadata as Record<string, unknown> | undefined,
      created_at: entry.created_at ?? new Date().toISOString(),
    }
  })
}

/**
 * Hook: Get recent activity
 */
export function useRecentActivity(limit: number = 20) {
  const { profile } = useAuthStore()

  return useQuery({
    queryKey: activityKeys.recent(limit),
    queryFn: () => fetchActivityLog({ limit }),
    enabled: !!profile,
    staleTime: 60 * 1000, // 1 minute
  })
}

/**
 * Hook: Get activity for specific entity
 */
export function useEntityActivity(entityType: ActivityEntityType, entityId: string) {
  const { profile } = useAuthStore()

  return useQuery({
    queryKey: activityKeys.entity(entityType, entityId),
    queryFn: async (): Promise<ActivityLogEntry[]> => {
      const { data, error } = await supabase
        .from('activity_log')
        .select(`
          *,
          user:users(first_name, last_name)
        `)
        .eq('entity_type', entityType)
        .eq('entity_id', entityId)
        .order('created_at', { ascending: false })

      if (error) throw error

      return (data ?? []).map((entry) => {
        const user = entry.user as { first_name?: string; last_name?: string } | null
        return {
          id: entry.id,
          user_id: entry.user_id,
          user_name: user
            ? `${user.first_name ?? ''} ${user.last_name ?? ''}`.trim() || 'Unknown'
            : 'System',
          action: entry.action as ActivityAction,
          entity_type: entry.entity_type as ActivityEntityType,
          entity_id: entry.entity_id,
          entity_name: entry.entity_name ?? undefined,
          changes: entry.changes as Record<string, { old: unknown; new: unknown }> | undefined,
          metadata: entry.metadata as Record<string, unknown> | undefined,
          created_at: entry.created_at ?? new Date().toISOString(),
        }
      })
    },
    enabled: !!profile && !!entityId,
  })
}

/**
 * Hook: Get paginated activity log
 */
export function useActivityLogInfinite(params: {
  entity_type?: ActivityEntityType
  user_id?: string
  pageSize?: number
} = {}) {
  const { profile } = useAuthStore()
  const pageSize = params.pageSize ?? 20

  return useInfiniteQuery({
    queryKey: activityKeys.list({ entity_type: params.entity_type, user_id: params.user_id }),
    queryFn: ({ pageParam = 0 }) =>
      fetchActivityLog({
        entity_type: params.entity_type,
        user_id: params.user_id,
        limit: pageSize,
        offset: pageParam * pageSize,
      }),
    initialPageParam: 0,
    getNextPageParam: (lastPage, allPages) => {
      return lastPage.length === pageSize ? allPages.length : undefined
    },
    enabled: !!profile,
  })
}

/**
 * Hook: Log activity
 */
export function useLogActivity() {
  const { profile } = useAuthStore()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (params: {
      action: ActivityAction
      entity_type: ActivityEntityType
      entity_id: string
      entity_name?: string
      changes?: Record<string, { old: unknown; new: unknown }>
      metadata?: Record<string, unknown>
    }) => {
      if (!profile?.organization_id) throw new Error('Not authenticated')

      const { error } = await supabase.from('activity_log').insert({
        organization_id: profile.organization_id,
        user_id: profile.id,
        action: params.action,
        entity_type: params.entity_type,
        entity_id: params.entity_id,
        entity_name: params.entity_name,
        changes: params.changes ?? {},
        metadata: params.metadata ?? {},
      })

      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: activityKeys.all })
    },
  })
}

/**
 * Helper: Log entity creation
 */
export function useLogEntityCreated() {
  const logActivity = useLogActivity()

  return {
    ...logActivity,
    log: async (entityType: ActivityEntityType, entityId: string, entityName?: string) => {
      return logActivity.mutateAsync({
        action: 'created',
        entity_type: entityType,
        entity_id: entityId,
        entity_name: entityName,
      })
    },
  }
}

/**
 * Helper: Log entity update
 */
export function useLogEntityUpdated() {
  const logActivity = useLogActivity()

  return {
    ...logActivity,
    log: async (
      entityType: ActivityEntityType,
      entityId: string,
      entityName?: string,
      changes?: Record<string, { old: unknown; new: unknown }>
    ) => {
      return logActivity.mutateAsync({
        action: 'updated',
        entity_type: entityType,
        entity_id: entityId,
        entity_name: entityName,
        changes,
      })
    },
  }
}

/**
 * Helper: Log entity deletion
 */
export function useLogEntityDeleted() {
  const logActivity = useLogActivity()

  return {
    ...logActivity,
    log: async (entityType: ActivityEntityType, entityId: string, entityName?: string) => {
      return logActivity.mutateAsync({
        action: 'deleted',
        entity_type: entityType,
        entity_id: entityId,
        entity_name: entityName,
      })
    },
  }
}
```

**Verification**: File exists with ~220 lines of activity hooks

### Task 4: Create notification trigger hooks
**File**: `apps/admin/src/hooks/use-notification-triggers.ts`

```typescript
import { useCreateNotification } from './use-notifications'
import { useSendEmail } from './use-email'
import { useNotificationPreferences } from './use-notification-preferences'
import { useAuthStore } from '@/stores/auth-store'
import {
  createInspectionReminderPayload,
  createWorkOrderNotificationPayload,
  createInvoiceNotificationPayload,
  getActiveChannels,
} from '@/lib/helpers/notifications'
import type {
  NotificationType,
  PriorityLevel,
  CreateNotificationPayload,
} from '@/lib/types/notification'

/**
 * Hook: Send notification with preferences check
 */
export function useSendNotificationWithPreferences() {
  const createNotification = useCreateNotification()
  const sendEmail = useSendEmail()
  const { data: preferences } = useNotificationPreferences()
  const { profile } = useAuthStore()

  const send = async (
    payload: CreateNotificationPayload,
    emailOptions?: {
      to: string
      template_type: string
      variables: Record<string, string | number | boolean>
    }
  ) => {
    if (!preferences) return

    const channels = getActiveChannels(
      preferences,
      payload.notification_type,
      payload.priority ?? 'medium'
    )

    // Always create in-app notification
    const notification = await createNotification.mutateAsync(payload)

    // Send email if channel is active
    if (channels.includes('email') && emailOptions) {
      try {
        await sendEmail.mutateAsync({
          ...emailOptions,
          template_type: emailOptions.template_type as Parameters<typeof sendEmail.mutateAsync>[0]['template_type'],
          notification_id: notification.id,
        })
      } catch (err) {
        console.error('Failed to send email notification:', err)
      }
    }

    return notification
  }

  return { send, isPending: createNotification.isPending || sendEmail.isPending }
}

/**
 * Hook: Notify about inspection scheduled
 */
export function useNotifyInspectionScheduled() {
  const sendWithPrefs = useSendNotificationWithPreferences()

  return {
    ...sendWithPrefs,
    notify: async (params: {
      userId: string
      userEmail: string
      clientName: string
      propertyName: string
      propertyAddress: string
      inspectionId: string
      inspectionDate: string
      inspectionTime: string
      inspectionType: string
      inspectorName: string
    }) => {
      const actionUrl = `/calendar?date=${params.inspectionDate.split('T')[0]}`

      const payload: CreateNotificationPayload = {
        user_id: params.userId,
        title: 'Inspection Scheduled',
        message: `Inspection scheduled at ${params.propertyName} on ${new Date(params.inspectionDate).toLocaleDateString()}`,
        notification_type: 'inspection',
        priority: 'medium',
        entity_type: 'inspection',
        entity_id: params.inspectionId,
        action_url: actionUrl,
      }

      return sendWithPrefs.send(payload, {
        to: params.userEmail,
        template_type: 'inspection_scheduled',
        variables: {
          client_name: params.clientName,
          property_name: params.propertyName,
          property_address: params.propertyAddress,
          inspection_date: new Date(params.inspectionDate).toLocaleDateString('en-US', {
            weekday: 'long',
            month: 'long',
            day: 'numeric',
            year: 'numeric',
          }),
          inspection_time: params.inspectionTime,
          inspection_type: params.inspectionType,
          inspector_name: params.inspectorName,
          action_url: `${window.location.origin}/portal/properties`,
        },
      })
    },
  }
}

/**
 * Hook: Notify about work order status change
 */
export function useNotifyWorkOrderStatus() {
  const sendWithPrefs = useSendNotificationWithPreferences()

  return {
    ...sendWithPrefs,
    notify: async (params: {
      userId: string
      userEmail: string
      userName: string
      workOrderNumber: string
      workOrderId: string
      propertyName: string
      propertyAddress: string
      category: string
      priority: PriorityLevel
      description: string
      status: string
    }) => {
      const payload = createWorkOrderNotificationPayload(
        params.userId,
        params.workOrderNumber,
        params.status,
        params.workOrderId,
        params.priority
      )

      return sendWithPrefs.send(payload, {
        to: params.userEmail,
        template_type: params.status === 'created' ? 'work_order_created' : 'work_order_status_update',
        variables: {
          recipient_name: params.userName,
          work_order_number: params.workOrderNumber,
          property_name: params.propertyName,
          property_address: params.propertyAddress,
          category: params.category,
          priority: params.priority,
          description: params.description,
          action_url: `${window.location.origin}/work-orders/${params.workOrderId}`,
        },
      })
    },
  }
}

/**
 * Hook: Notify about invoice
 */
export function useNotifyInvoice() {
  const sendWithPrefs = useSendNotificationWithPreferences()

  return {
    ...sendWithPrefs,
    notify: async (params: {
      userId: string
      userEmail: string
      clientName: string
      invoiceNumber: string
      invoiceId: string
      amount: number
      dueDate: string
      lineItems: Array<{ description: string; amount: string }>
      eventType: 'created' | 'due_soon' | 'overdue' | 'paid'
      paymentUrl?: string
    }) => {
      const payload = createInvoiceNotificationPayload(
        params.userId,
        params.invoiceNumber,
        params.invoiceId,
        params.eventType,
        params.amount
      )

      const formattedAmount = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
      }).format(params.amount)

      let templateType: 'invoice_created' | 'invoice_overdue' | 'payment_received' = 'invoice_created'
      if (params.eventType === 'overdue') templateType = 'invoice_overdue'
      if (params.eventType === 'paid') templateType = 'payment_received'

      return sendWithPrefs.send(payload, {
        to: params.userEmail,
        template_type: templateType,
        variables: {
          client_name: params.clientName,
          invoice_number: params.invoiceNumber,
          amount: formattedAmount,
          due_date: new Date(params.dueDate).toLocaleDateString('en-US', {
            month: 'long',
            day: 'numeric',
            year: 'numeric',
          }),
          payment_url: params.paymentUrl ?? `${window.location.origin}/portal/invoices`,
          portal_url: `${window.location.origin}/portal/invoices`,
          line_items: params.lineItems,
        },
      })
    },
  }
}

/**
 * Hook: Notify about payment received
 */
export function useNotifyPaymentReceived() {
  const sendWithPrefs = useSendNotificationWithPreferences()

  return {
    ...sendWithPrefs,
    notify: async (params: {
      userId: string
      userEmail: string
      clientName: string
      invoiceNumber: string
      invoiceId: string
      amount: number
      paymentMethod: string
      remainingBalance: number
    }) => {
      const formattedAmount = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
      }).format(params.amount)

      const formattedBalance = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
      }).format(params.remainingBalance)

      const payload = createInvoiceNotificationPayload(
        params.userId,
        params.invoiceNumber,
        params.invoiceId,
        'paid',
        params.amount
      )

      return sendWithPrefs.send(payload, {
        to: params.userEmail,
        template_type: 'payment_received',
        variables: {
          client_name: params.clientName,
          amount: formattedAmount,
          invoice_number: params.invoiceNumber,
          payment_method: params.paymentMethod,
          payment_date: new Date().toLocaleDateString('en-US', {
            month: 'long',
            day: 'numeric',
            year: 'numeric',
          }),
          remaining_balance: formattedBalance,
        },
      })
    },
  }
}

/**
 * Hook: Notify about report ready
 */
export function useNotifyReportReady() {
  const sendWithPrefs = useSendNotificationWithPreferences()

  return {
    ...sendWithPrefs,
    notify: async (params: {
      userId: string
      userEmail: string
      clientName: string
      propertyName: string
      inspectionId: string
      inspectionDate: string
      overallCondition: string
      findingsSummary: string
      recommendationsCount: number
      reportUrl: string
    }) => {
      const payload: CreateNotificationPayload = {
        user_id: params.userId,
        title: 'Inspection Report Ready',
        message: `Your inspection report for ${params.propertyName} is now available`,
        notification_type: 'inspection',
        priority: 'medium',
        entity_type: 'inspection',
        entity_id: params.inspectionId,
        action_url: `/inspections/${params.inspectionId}/report`,
      }

      return sendWithPrefs.send(payload, {
        to: params.userEmail,
        template_type: 'report_ready',
        variables: {
          client_name: params.clientName,
          property_name: params.propertyName,
          inspection_date: new Date(params.inspectionDate).toLocaleDateString('en-US', {
            month: 'long',
            day: 'numeric',
            year: 'numeric',
          }),
          overall_condition: params.overallCondition,
          findings_summary: params.findingsSummary,
          recommendations_count: params.recommendationsCount,
          report_url: params.reportUrl,
          portal_url: `${window.location.origin}/portal/properties`,
        },
      })
    },
  }
}
```

**Verification**: File exists with ~280 lines of trigger hooks

## Verification

```bash
ls -la apps/admin/src/hooks/use-notifications.ts
ls -la apps/admin/src/hooks/use-notification-preferences.ts
ls -la apps/admin/src/hooks/use-activity-log.ts
ls -la apps/admin/src/hooks/use-notification-triggers.ts
```

## Files Created

| File | Description | Lines |
|------|-------------|-------|
| `hooks/use-notifications.ts` | Notification CRUD hooks | ~200 |
| `hooks/use-notification-preferences.ts` | User preference hooks | ~120 |
| `hooks/use-activity-log.ts` | Activity log hooks | ~220 |
| `hooks/use-notification-triggers.ts` | Event trigger hooks | ~280 |

## Commit Message

```
feat(notifications): add notification and activity log hooks

- Add notification CRUD hooks with real-time subscription
- Add user notification preference hooks
- Add activity log hooks with infinite scroll
- Add notification trigger hooks for common events
```
