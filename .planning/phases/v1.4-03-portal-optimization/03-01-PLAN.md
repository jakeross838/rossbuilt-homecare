---
phase: v1.4-03-portal-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/032_portal_property_summaries_view.sql
autonomous: true

must_haves:
  truths:
    - "Database view portal_property_summaries exists and returns data"
    - "View pre-aggregates equipment_count, open_work_order_count, pending_recommendation_count per property"
    - "View includes last_inspection_date, last_inspection_condition, next_inspection_date per property"
  artifacts:
    - path: "supabase/migrations/032_portal_property_summaries_view.sql"
      provides: "Database view with pre-aggregated portal counts"
      contains: "CREATE OR REPLACE VIEW portal_property_summaries"
  key_links:
    - from: "portal_property_summaries view"
      to: "properties, equipment, work_orders, recommendations, inspections tables"
      via: "LEFT JOINs with aggregation"
      pattern: "GROUP BY properties.id"
---

<objective>
Create a database view that pre-aggregates all per-property counts needed by the portal, eliminating N+1 queries.

Purpose: The portal properties page currently makes 5 queries PER property (equipment count, work order count, recommendations count, last inspection, next inspection). With 10 properties, that's 50+ queries. This view reduces it to 1.

Output: Migration file creating `portal_property_summaries` view that returns all property data plus aggregated counts in a single query.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS-v1.4.md

Key schema files:
@supabase/migrations/004_properties.sql
@supabase/migrations/005_programs.sql
@supabase/migrations/006_equipment.sql
@supabase/migrations/008_inspections.sql
@supabase/migrations/009_recommendations.sql
@supabase/migrations/010_vendors_work_orders.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create portal_property_summaries database view</name>
  <files>supabase/migrations/032_portal_property_summaries_view.sql</files>
  <action>
Create a migration file that creates a database view `portal_property_summaries` with:

**Base property columns:**
- id, name, address_line1, city, state, zip, primary_photo_url
- is_active (for filtering)

**Program data (LEFT JOIN to programs where status = 'active'):**
- program_id, inspection_tier, inspection_frequency, program_status, monthly_total

**Aggregated counts using subqueries or LEFT JOIN with aggregation:**
- equipment_count: COUNT of equipment WHERE property_id = p.id AND is_active = true
- open_work_order_count: COUNT of work_orders WHERE property_id = p.id AND status IN ('pending', 'vendor_assigned', 'scheduled', 'in_progress')
- pending_recommendation_count: COUNT of recommendations WHERE property_id = p.id AND status = 'pending'

**Inspection data using LATERAL joins or subqueries:**
- last_inspection_date: MAX(scheduled_date) from inspections WHERE status = 'completed'
- last_inspection_condition: overall_condition from the last completed inspection
- next_inspection_date: MIN(scheduled_date) from inspections WHERE status = 'scheduled' AND scheduled_date >= CURRENT_DATE

Use this pattern for efficient aggregation:

```sql
CREATE OR REPLACE VIEW portal_property_summaries AS
SELECT
  p.id,
  p.name,
  p.address_line1,
  p.city,
  p.state,
  p.zip,
  p.primary_photo_url,
  p.is_active,

  -- Program data
  prog.id AS program_id,
  prog.inspection_tier,
  prog.inspection_frequency,
  prog.status AS program_status,
  prog.monthly_total,

  -- Counts via subqueries (more efficient than multiple JOINs)
  COALESCE(eq.equipment_count, 0) AS equipment_count,
  COALESCE(wo.open_work_order_count, 0) AS open_work_order_count,
  COALESCE(rec.pending_recommendation_count, 0) AS pending_recommendation_count,

  -- Last completed inspection
  last_insp.scheduled_date AS last_inspection_date,
  last_insp.overall_condition AS last_inspection_condition,

  -- Next scheduled inspection
  next_insp.scheduled_date AS next_inspection_date

FROM properties p

-- Active program (one per property)
LEFT JOIN programs prog
  ON prog.property_id = p.id
  AND prog.status = 'active'

-- Equipment count
LEFT JOIN LATERAL (
  SELECT COUNT(*)::int AS equipment_count
  FROM equipment e
  WHERE e.property_id = p.id AND e.is_active = true
) eq ON true

-- Open work orders count
LEFT JOIN LATERAL (
  SELECT COUNT(*)::int AS open_work_order_count
  FROM work_orders w
  WHERE w.property_id = p.id
    AND w.status IN ('pending', 'vendor_assigned', 'scheduled', 'in_progress')
) wo ON true

-- Pending recommendations count
LEFT JOIN LATERAL (
  SELECT COUNT(*)::int AS pending_recommendation_count
  FROM recommendations r
  WHERE r.property_id = p.id AND r.status = 'pending'
) rec ON true

-- Last completed inspection
LEFT JOIN LATERAL (
  SELECT i.scheduled_date, i.overall_condition
  FROM inspections i
  WHERE i.property_id = p.id AND i.status = 'completed'
  ORDER BY i.scheduled_date DESC
  LIMIT 1
) last_insp ON true

-- Next scheduled inspection
LEFT JOIN LATERAL (
  SELECT i.scheduled_date
  FROM inspections i
  WHERE i.property_id = p.id
    AND i.status = 'scheduled'
    AND i.scheduled_date >= CURRENT_DATE
  ORDER BY i.scheduled_date ASC
  LIMIT 1
) next_insp ON true;
```

Add comment explaining the view's purpose.
  </action>
  <verify>
Run `npx supabase db push` to apply migration. Verify view exists by running:
```sql
SELECT * FROM portal_property_summaries LIMIT 5;
```
  </verify>
  <done>View portal_property_summaries exists and returns property data with all aggregated counts in a single query.</done>
</task>

<task type="auto">
  <name>Task 2: Generate TypeScript types for the view</name>
  <files>apps/admin/src/lib/types/database.types.ts</files>
  <action>
After pushing the migration, regenerate TypeScript types to include the view:

```bash
cd "P:/Claude Projects/home-care-os"
export SUPABASE_ACCESS_TOKEN=$(grep SUPABASE_ACCESS_TOKEN .env.supabase | cut -d '=' -f2)
npx supabase gen types typescript --project-id qzbmnbinhxzkcwfjnmtb > apps/admin/src/lib/types/database.types.ts
```

The view should appear in the generated types as `portal_property_summaries` in the `Views` section.
  </action>
  <verify>
Check that `database.types.ts` contains the view type definition:
```bash
grep -A 20 "portal_property_summaries" apps/admin/src/lib/types/database.types.ts
```
  </verify>
  <done>TypeScript types include portal_property_summaries view with all columns typed.</done>
</task>

</tasks>

<verification>
1. Migration file exists at `supabase/migrations/032_portal_property_summaries_view.sql`
2. View creates successfully when migration is pushed
3. View returns correct data structure with all required columns
4. TypeScript types are regenerated and include the view
5. No existing functionality broken (view is additive, no changes to tables)
</verification>

<success_criteria>
- Database view `portal_property_summaries` exists
- View returns: id, name, address, photo, program info, equipment_count, open_work_order_count, pending_recommendation_count, last_inspection_date, last_inspection_condition, next_inspection_date
- View can be queried from Supabase client
- TypeScript types generated for the view
</success_criteria>

<output>
After completion, create `.planning/phases/v1.4-03-portal-optimization/03-01-SUMMARY.md`
</output>
