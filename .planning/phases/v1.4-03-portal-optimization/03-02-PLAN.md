---
phase: v1.4-03-portal-optimization
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/admin/src/hooks/use-portal-dashboard.ts
  - apps/admin/src/lib/queries/keys.ts
autonomous: true

must_haves:
  truths:
    - "usePortalProperties() makes a single query to portal_property_summaries view"
    - "usePortalDashboard() fetches counts in parallel (not waterfall)"
    - "Portal properties page loads with < 5 total queries"
    - "No Promise.all(properties.map(...)) pattern exists in portal hooks"
  artifacts:
    - path: "apps/admin/src/hooks/use-portal-dashboard.ts"
      provides: "Optimized portal hooks using database view"
      min_lines: 50
  key_links:
    - from: "usePortalProperties hook"
      to: "portal_property_summaries view"
      via: "supabase.from('portal_property_summaries')"
      pattern: "from\\('portal_property_summaries'\\)"
---

<objective>
Update portal hooks to use the new database view instead of N+1 queries.

Purpose: Replace the Promise.all(properties.map(...)) anti-pattern with a single view query, reducing 50+ queries to < 5.

Output: Updated `use-portal-dashboard.ts` that queries the view directly and fetches dashboard data in parallel.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS-v1.4.md

Prior plan summary:
@.planning/phases/v1.4-03-portal-optimization/03-01-SUMMARY.md

Current hook to optimize:
@apps/admin/src/hooks/use-portal-dashboard.ts
@apps/admin/src/lib/types/portal.ts
@apps/admin/src/lib/queries/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add view query key to registry</name>
  <files>apps/admin/src/lib/queries/keys.ts</files>
  <action>
Add a new key factory for the portal property summaries view query in the portalKeys object:

```typescript
// In the portalKeys factory
export const portalKeys = {
  all: ['portal'] as const,
  dashboard: () => [...portalKeys.all, 'dashboard'] as const,
  properties: () => [...portalKeys.all, 'properties'] as const,
  propertySummaries: () => [...portalKeys.all, 'property-summaries'] as const,  // NEW
  property: (id: string) => [...portalKeys.all, 'property', id] as const,
  // ... rest unchanged
}
```

This allows the new view-based query to be cached separately and invalidated correctly.
  </action>
  <verify>
TypeScript compiles without errors. Key factory is accessible:
```bash
grep "propertySummaries" apps/admin/src/lib/queries/keys.ts
```
  </verify>
  <done>portalKeys.propertySummaries() key factory added to registry.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite usePortalProperties to use view</name>
  <files>apps/admin/src/hooks/use-portal-dashboard.ts</files>
  <action>
Replace the entire `usePortalProperties()` function to query the view directly instead of using N+1 pattern.

**Before (N+1 pattern - REMOVE):**
```typescript
// Fetch properties
const { data: properties } = await supabase.from('properties')...

// N+1: For each property, get counts
const propertiesWithCounts = await Promise.all(
  (properties || []).map(async (prop) => {
    const { count: equipmentCount } = await supabase...
    const { count: openWorkOrders } = await supabase...
    // ... 5 queries per property
  })
)
```

**After (single view query):**
```typescript
export function usePortalProperties() {
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: portalKeys.propertySummaries(),
    queryFn: async (): Promise<PortalProperty[]> => {
      if (!profile?.id) {
        throw new Error('User not authenticated')
      }

      // Get property IDs assigned to this user
      const { data: assignments, error: assignmentError } = await supabase
        .from('user_property_assignments')
        .select('property_id')
        .eq('user_id', profile.id)

      if (assignmentError) throw assignmentError

      if (!assignments || assignments.length === 0) {
        return []
      }

      const assignedPropertyIds = assignments.map((a) => a.property_id)

      // Single query to view with all pre-aggregated data
      const { data: summaries, error } = await supabase
        .from('portal_property_summaries')
        .select('*')
        .in('id', assignedPropertyIds)
        .eq('is_active', true)
        .order('name')

      if (error) throw error

      // Map view data to PortalProperty shape
      return (summaries || []).map((s) => ({
        id: s.id,
        name: s.name,
        address_line1: s.address_line1,
        city: s.city,
        state: s.state,
        zip: s.zip,
        primary_photo_url: s.primary_photo_url,
        program: s.program_id ? {
          id: s.program_id,
          tier: s.inspection_tier,
          frequency: s.inspection_frequency,
          status: s.program_status,
          monthly_price: s.monthly_total,
          next_inspection_date: s.next_inspection_date,
        } : null,
        equipment_count: s.equipment_count,
        open_work_order_count: s.open_work_order_count,
        pending_recommendation_count: s.pending_recommendation_count,
        last_inspection_date: s.last_inspection_date,
        overall_condition: s.last_inspection_condition,
      } satisfies PortalProperty))
    },
    enabled: profile?.role === 'client',
    staleTime: STALE_STANDARD,
  })
}
```

Key changes:
1. Use `portalKeys.propertySummaries()` instead of `portalKeys.properties()`
2. Query `portal_property_summaries` view instead of `properties` table
3. Remove entire Promise.all(...map...) block
4. Map view columns directly to PortalProperty type
5. Add staleTime import if not present
  </action>
  <verify>
1. TypeScript compiles: `cd apps/admin && npx tsc --noEmit`
2. No Promise.all(map pattern: `grep -n "Promise.all.*map" apps/admin/src/hooks/use-portal-dashboard.ts` should return nothing
3. View query exists: `grep -n "portal_property_summaries" apps/admin/src/hooks/use-portal-dashboard.ts`
  </verify>
  <done>usePortalProperties queries view directly with no N+1 pattern.</done>
</task>

<task type="auto">
  <name>Task 3: Optimize usePortalDashboard for parallel fetching</name>
  <files>apps/admin/src/hooks/use-portal-dashboard.ts</files>
  <action>
Review `usePortalDashboard()` and ensure it fetches counts in parallel, not waterfall.

The current implementation already does sequential queries (one after another). Optimize to use Promise.all for independent count queries:

```typescript
export function usePortalDashboard() {
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: portalKeys.dashboard(),
    queryFn: async (): Promise<PortalDashboardSummary> => {
      if (!profile?.id) {
        throw new Error('User not authenticated')
      }

      // Get assigned property IDs (needed for all queries)
      const { data: assignments } = await supabase
        .from('user_property_assignments')
        .select('property_id')
        .eq('user_id', profile.id)

      const assignedPropertyIds = assignments?.map((a) => a.property_id) || []

      if (assignedPropertyIds.length === 0) {
        return {
          properties_count: 0,
          upcoming_inspections: 0,
          open_service_requests: 0,
          pending_approvals: 0,
          outstanding_balance: 0,
        }
      }

      const thirtyDaysFromNow = new Date()
      thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30)

      // Fetch ALL counts in parallel
      const [
        propertiesResult,
        inspectionsResult,
        requestsResult,
        approvalsResult,
        invoicesResult,
      ] = await Promise.all([
        // Properties count
        supabase
          .from('properties')
          .select('*', { count: 'exact', head: true })
          .in('id', assignedPropertyIds)
          .eq('is_active', true),

        // Upcoming inspections (next 30 days)
        supabase
          .from('inspections')
          .select('*', { count: 'exact', head: true })
          .in('property_id', assignedPropertyIds)
          .eq('status', 'scheduled')
          .gte('scheduled_date', new Date().toISOString())
          .lte('scheduled_date', thirtyDaysFromNow.toISOString()),

        // Open service requests
        supabase
          .from('service_requests')
          .select('*', { count: 'exact', head: true })
          .in('property_id', assignedPropertyIds)
          .in('status', ['new', 'acknowledged', 'in_progress', 'scheduled']),

        // Pending recommendations
        supabase
          .from('recommendations')
          .select('*', { count: 'exact', head: true })
          .in('property_id', assignedPropertyIds)
          .eq('status', 'pending'),

        // Outstanding invoices
        supabase
          .from('invoices')
          .select('balance_due')
          .in('property_id', assignedPropertyIds)
          .in('status', ['sent', 'viewed', 'partial', 'overdue']),
      ])

      const outstandingBalance = invoicesResult.data?.reduce(
        (sum, inv) => sum + (inv.balance_due || 0),
        0
      ) || 0

      return {
        properties_count: propertiesResult.count || 0,
        upcoming_inspections: inspectionsResult.count || 0,
        open_service_requests: requestsResult.count || 0,
        pending_approvals: approvalsResult.count || 0,
        outstanding_balance: outstandingBalance,
      }
    },
    enabled: profile?.role === 'client',
    staleTime: STALE_STANDARD,
  })
}
```

Key changes:
1. Wrap all 5 count queries in a single Promise.all (parallel, not sequential)
2. Keep the same logic but execute concurrently
3. This reduces latency from 5 sequential round-trips to 1 parallel batch
  </action>
  <verify>
1. TypeScript compiles: `cd apps/admin && npx tsc --noEmit`
2. Promise.all used for counts: `grep -A 5 "Promise.all" apps/admin/src/hooks/use-portal-dashboard.ts`
  </verify>
  <done>usePortalDashboard fetches all 5 counts in parallel via Promise.all.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. No N+1 pattern in usePortalProperties (no Promise.all with map over properties)
3. usePortalProperties queries portal_property_summaries view
4. usePortalDashboard uses Promise.all for parallel count fetching
5. Portal properties page still renders correctly (manual test)
6. Query count verification: Enable Supabase debug logging or check Network tab - should see < 5 queries on portal load
</verification>

<success_criteria>
- usePortalProperties() uses single view query (no N+1)
- usePortalDashboard() fetches in parallel (not waterfall)
- Portal properties page makes < 5 queries total on load
- Promise.all(properties.map(...)) anti-pattern removed
- TypeScript types preserved (PortalProperty shape unchanged)
- No functional regressions (portal still works)
</success_criteria>

<output>
After completion, create `.planning/phases/v1.4-03-portal-optimization/03-02-SUMMARY.md`
</output>
