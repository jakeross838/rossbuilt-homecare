# Plan 01-01: Permission System Setup

## Objective
Establish the permission infrastructure foundation including role types, permission matrix, CASL ability definitions, and permission hooks. This creates the core permission checking system that route protection and UI guards will consume.

## Requirements Addressed
- **PERM-01**: System supports three roles: Admin, Client, Tech
- **QA-02**: Permission matrix is enforced (foundation for enforcement)

## Prerequisites
- Existing auth store (`apps/admin/src/stores/auth-store.ts`) provides user profile with role
- Existing database enum `user_role` includes the roles: admin, manager, inspector, client
- Note: The existing roles map to our target roles:
  - `admin` -> Admin
  - `client` -> Client
  - `inspector` + `manager` -> Tech (staff roles)

## Files to Create/Modify

### New Files
- `apps/admin/src/lib/permissions/roles.ts` — Role type definitions and mapping
- `apps/admin/src/lib/permissions/matrix.ts` — Permission matrix configuration
- `apps/admin/src/lib/permissions/ability.ts` — CASL ability factory
- `apps/admin/src/hooks/use-permissions.ts` — Permission checking hook
- `apps/admin/src/components/providers/permission-provider.tsx` — CASL ability context provider

### Modified Files
- `apps/admin/package.json` — Add CASL and jwt-decode dependencies

## Implementation Tasks

### Task 1: Install Dependencies
**File:** `apps/admin/package.json`
**Action:** Modify

Add the required npm packages for permission management:

```bash
cd apps/admin && npm install @casl/ability@^6.8.0 @casl/react@^5.0.0 jwt-decode@^4.0.0
```

**Dependencies:**
- `@casl/ability` (^6.8.x) - Core CASL permission library
- `@casl/react` (^5.0.x) - React bindings for CASL
- `jwt-decode` (^4.0.x) - Decode Supabase JWT to extract custom claims

### Task 2: Create Role Type Definitions
**File:** `apps/admin/src/lib/permissions/roles.ts`
**Action:** Create

```typescript
/**
 * Role definitions and mapping for permission system
 *
 * Maps database user_role enum to application permission roles.
 * The database has: admin, manager, inspector, client
 * The permission system uses: Admin, Client, Tech
 */

import type { Database } from '@/types/database'

/**
 * Database role type from Supabase enum
 */
export type DatabaseRole = Database['public']['Enums']['user_role']

/**
 * Application permission roles
 * - Admin: Full access to all pages and features
 * - Client: Limited access to client-facing pages only
 * - Tech: Staff access (inspectors, managers) - most pages except dashboard
 */
export type PermissionRole = 'Admin' | 'Client' | 'Tech'

/**
 * Map database roles to permission roles
 *
 * admin -> Admin (full access)
 * client -> Client (limited access)
 * manager, inspector -> Tech (staff access)
 */
export function mapDatabaseRoleToPermissionRole(
  dbRole: DatabaseRole | null | undefined
): PermissionRole {
  if (!dbRole) {
    return 'Client' // Default to most restrictive
  }

  switch (dbRole) {
    case 'admin':
      return 'Admin'
    case 'client':
      return 'Client'
    case 'manager':
    case 'inspector':
      return 'Tech'
    default:
      return 'Client' // Default to most restrictive for unknown roles
  }
}

/**
 * Check if a role has admin privileges
 */
export function isAdmin(role: PermissionRole): boolean {
  return role === 'Admin'
}

/**
 * Check if a role is a staff member (Admin or Tech)
 */
export function isStaff(role: PermissionRole): boolean {
  return role === 'Admin' || role === 'Tech'
}

/**
 * Check if a role is a client
 */
export function isClient(role: PermissionRole): boolean {
  return role === 'Client'
}
```

### Task 3: Create Permission Matrix
**File:** `apps/admin/src/lib/permissions/matrix.ts`
**Action:** Create

```typescript
/**
 * Permission matrix defining page access by role
 *
 * This matrix is the single source of truth for route permissions.
 * Used by both route guards and sidebar navigation filtering.
 */

import type { PermissionRole } from './roles'

/**
 * Page identifiers matching route paths
 * These are the "subjects" in CASL terminology
 */
export type PageSubject =
  | 'dashboard'
  | 'billing'
  | 'work-orders'
  | 'inspections'
  | 'calendar'
  | 'clients'
  | 'properties'
  | 'vendors'
  | 'inspector'
  | 'activity'
  | 'notifications'
  | 'settings'
  | 'reports'

/**
 * Permission matrix configuration
 * true = allowed, false = denied
 *
 * From requirements:
 * | Page | Admin | Client | Tech |
 * |------|-------|--------|------|
 * | dashboard | Y | N | N |
 * | billing | Y | Y | Y |
 * | work-orders | Y | Y | Y |
 * | inspections | Y | Y | Y |
 * | calendar | Y | Y | Y |
 * | clients | Y | N | Y |
 * | properties | Y | N | Y |
 * | vendors | Y | N | Y |
 * | inspector | Y | N | Y |
 * | activity | Y | N | Y |
 * | notifications | Y | N | Y |
 * | settings | Y | N | Y |
 */
export const permissionMatrix: Record<PageSubject, Record<PermissionRole, boolean>> = {
  dashboard: {
    Admin: true,
    Client: false,
    Tech: false,
  },
  billing: {
    Admin: true,
    Client: true,
    Tech: true,
  },
  'work-orders': {
    Admin: true,
    Client: true,
    Tech: true,
  },
  inspections: {
    Admin: true,
    Client: true,
    Tech: true,
  },
  calendar: {
    Admin: true,
    Client: true,
    Tech: true,
  },
  clients: {
    Admin: true,
    Client: false,
    Tech: true,
  },
  properties: {
    Admin: true,
    Client: false,
    Tech: true,
  },
  vendors: {
    Admin: true,
    Client: false,
    Tech: true,
  },
  inspector: {
    Admin: true,
    Client: false,
    Tech: true,
  },
  activity: {
    Admin: true,
    Client: false,
    Tech: true,
  },
  notifications: {
    Admin: true,
    Client: false,
    Tech: true,
  },
  settings: {
    Admin: true,
    Client: false,
    Tech: true,
  },
  reports: {
    Admin: true,
    Client: false,
    Tech: true,
  },
}

/**
 * Get allowed pages for a role
 */
export function getAllowedPages(role: PermissionRole): PageSubject[] {
  return (Object.keys(permissionMatrix) as PageSubject[]).filter(
    (page) => permissionMatrix[page][role]
  )
}

/**
 * Check if a role can access a page
 */
export function canAccessPage(role: PermissionRole, page: PageSubject): boolean {
  return permissionMatrix[page]?.[role] ?? false
}

/**
 * Get the default redirect page for a role when accessing unauthorized content
 */
export function getDefaultPageForRole(role: PermissionRole): string {
  switch (role) {
    case 'Admin':
      return '/dashboard'
    case 'Client':
      return '/portal' // Clients go to the client portal
    case 'Tech':
      return '/calendar' // Tech staff start with calendar
    default:
      return '/login'
  }
}

/**
 * Route to page subject mapping
 * Maps URL paths to permission subjects
 */
export function routeToPageSubject(pathname: string): PageSubject | null {
  // Remove leading slash and get first segment
  const segment = pathname.replace(/^\//, '').split('/')[0]

  // Map route segments to page subjects
  const routeMap: Record<string, PageSubject> = {
    dashboard: 'dashboard',
    billing: 'billing',
    'work-orders': 'work-orders',
    inspections: 'inspections',
    calendar: 'calendar',
    clients: 'clients',
    properties: 'properties',
    vendors: 'vendors',
    inspector: 'inspector',
    activity: 'activity',
    notifications: 'notifications',
    settings: 'settings',
    reports: 'reports',
  }

  return routeMap[segment] ?? null
}
```

### Task 4: Create CASL Ability Factory
**File:** `apps/admin/src/lib/permissions/ability.ts`
**Action:** Create

```typescript
/**
 * CASL ability factory
 *
 * Creates CASL Ability instances based on user role.
 * Integrates with the permission matrix for consistent enforcement.
 */

import { Ability, AbilityBuilder, AbilityClass } from '@casl/ability'
import { permissionMatrix, type PageSubject } from './matrix'
import { type PermissionRole } from './roles'

/**
 * CASL action types
 * - 'access' is used for page/route access
 * - Additional actions can be added for fine-grained permissions
 */
export type PermissionAction = 'access' | 'manage' | 'read' | 'create' | 'update' | 'delete'

/**
 * CASL subject types
 */
export type PermissionSubject = PageSubject | 'all'

/**
 * Application ability type
 */
export type AppAbility = Ability<[PermissionAction, PermissionSubject]>

/**
 * Ability class for type-safe ability creation
 */
export const AppAbilityClass = Ability as AbilityClass<AppAbility>

/**
 * Create a CASL ability based on user role
 *
 * @param role - The user's permission role
 * @returns CASL Ability instance with appropriate permissions
 */
export function createAbilityForRole(role: PermissionRole | null): AppAbility {
  const { can, cannot, build } = new AbilityBuilder<AppAbility>(AppAbilityClass)

  if (!role) {
    // No role = no permissions
    cannot('access', 'all')
    return build()
  }

  // Apply permissions from matrix
  for (const [page, permissions] of Object.entries(permissionMatrix)) {
    if (permissions[role]) {
      can('access', page as PageSubject)
    } else {
      cannot('access', page as PageSubject)
    }
  }

  // Admin gets full management capabilities
  if (role === 'Admin') {
    can('manage', 'all')
  }

  // Tech staff can read and update most things
  if (role === 'Tech') {
    can(['read', 'create', 'update'], 'all')
  }

  // Clients have limited capabilities
  if (role === 'Client') {
    can('read', 'all') // Can read their own data
  }

  return build()
}

/**
 * Create an empty ability (no permissions)
 * Used during loading states
 */
export function createEmptyAbility(): AppAbility {
  return new AppAbilityClass([])
}
```

### Task 5: Create Permission Provider
**File:** `apps/admin/src/components/providers/permission-provider.tsx`
**Action:** Create

```typescript
/**
 * Permission Provider
 *
 * Wraps the application with CASL ability context.
 * Creates and updates ability based on user role from auth store.
 */

import { createContext, useContext, useMemo, type ReactNode } from 'react'
import { createContextualCan } from '@casl/react'
import { useAuthStore } from '@/stores/auth-store'
import {
  createAbilityForRole,
  createEmptyAbility,
  type AppAbility,
} from '@/lib/permissions/ability'
import {
  mapDatabaseRoleToPermissionRole,
  type PermissionRole,
} from '@/lib/permissions/roles'

/**
 * Permission context value
 */
interface PermissionContextValue {
  ability: AppAbility
  role: PermissionRole | null
  isLoading: boolean
}

/**
 * Permission context
 */
const PermissionContext = createContext<PermissionContextValue>({
  ability: createEmptyAbility(),
  role: null,
  isLoading: true,
})

/**
 * CASL Can component bound to our context
 * Usage: <Can I="access" a="dashboard">...</Can>
 */
export const Can = createContextualCan(PermissionContext.Consumer)

/**
 * Permission provider props
 */
interface PermissionProviderProps {
  children: ReactNode
}

/**
 * Permission Provider component
 *
 * Provides CASL ability context based on user role from auth store.
 * Updates ability when user role changes.
 */
export function PermissionProvider({ children }: PermissionProviderProps) {
  const { profile, isLoading, isInitialized } = useAuthStore()

  // Map database role to permission role
  const role = useMemo(() => {
    if (!profile?.role) return null
    return mapDatabaseRoleToPermissionRole(profile.role)
  }, [profile?.role])

  // Create ability based on role
  const ability = useMemo(() => {
    if (!isInitialized || isLoading) {
      return createEmptyAbility()
    }
    return createAbilityForRole(role)
  }, [role, isInitialized, isLoading])

  const value = useMemo(
    () => ({
      ability,
      role,
      isLoading: !isInitialized || isLoading,
    }),
    [ability, role, isInitialized, isLoading]
  )

  return (
    <PermissionContext.Provider value={value}>
      {children}
    </PermissionContext.Provider>
  )
}

/**
 * Hook to access permission context
 */
export function usePermissionContext(): PermissionContextValue {
  const context = useContext(PermissionContext)
  if (!context) {
    throw new Error('usePermissionContext must be used within PermissionProvider')
  }
  return context
}

export default PermissionProvider
```

### Task 6: Create Permission Hook
**File:** `apps/admin/src/hooks/use-permissions.ts`
**Action:** Create

```typescript
/**
 * Permission checking hook
 *
 * Provides convenient methods for checking permissions throughout the app.
 * Uses CASL ability from PermissionProvider context.
 */

import { useAbility } from '@casl/react'
import { usePermissionContext } from '@/components/providers/permission-provider'
import { type AppAbility } from '@/lib/permissions/ability'
import { type PageSubject, canAccessPage, getDefaultPageForRole, routeToPageSubject } from '@/lib/permissions/matrix'
import { type PermissionRole, isAdmin, isStaff, isClient } from '@/lib/permissions/roles'

/**
 * Hook return type
 */
interface UsePermissionsReturn {
  /** Current user's permission role */
  role: PermissionRole | null
  /** Whether permissions are still loading */
  isLoading: boolean
  /** CASL ability instance */
  ability: AppAbility
  /** Check if user can access a specific page */
  canAccess: (page: PageSubject) => boolean
  /** Check if current route is accessible */
  canAccessRoute: (pathname: string) => boolean
  /** Get appropriate redirect for unauthorized access */
  getRedirectPath: () => string
  /** Check if user is admin */
  isAdmin: boolean
  /** Check if user is staff (Admin or Tech) */
  isStaff: boolean
  /** Check if user is client */
  isClient: boolean
}

/**
 * Permission checking hook
 *
 * @example
 * ```tsx
 * function MyComponent() {
 *   const { canAccess, isAdmin, role } = usePermissions()
 *
 *   if (!canAccess('dashboard')) {
 *     return <Navigate to="/calendar" />
 *   }
 *
 *   return <Dashboard />
 * }
 * ```
 */
export function usePermissions(): UsePermissionsReturn {
  const { role, isLoading, ability } = usePermissionContext()

  return {
    role,
    isLoading,
    ability,
    canAccess: (page: PageSubject) => {
      if (!role) return false
      return canAccessPage(role, page)
    },
    canAccessRoute: (pathname: string) => {
      if (!role) return false
      const page = routeToPageSubject(pathname)
      if (!page) return true // Unknown routes handled by router
      return canAccessPage(role, page)
    },
    getRedirectPath: () => {
      if (!role) return '/login'
      return getDefaultPageForRole(role)
    },
    isAdmin: role ? isAdmin(role) : false,
    isStaff: role ? isStaff(role) : false,
    isClient: role ? isClient(role) : false,
  }
}

/**
 * Re-export CASL useAbility for direct ability access
 */
export { useAbility }

export default usePermissions
```

### Task 7: Create Index Exports
**File:** `apps/admin/src/lib/permissions/index.ts`
**Action:** Create

```typescript
/**
 * Permission system exports
 */

// Role utilities
export {
  type DatabaseRole,
  type PermissionRole,
  mapDatabaseRoleToPermissionRole,
  isAdmin,
  isStaff,
  isClient,
} from './roles'

// Permission matrix
export {
  type PageSubject,
  permissionMatrix,
  getAllowedPages,
  canAccessPage,
  getDefaultPageForRole,
  routeToPageSubject,
} from './matrix'

// CASL ability
export {
  type PermissionAction,
  type PermissionSubject,
  type AppAbility,
  AppAbilityClass,
  createAbilityForRole,
  createEmptyAbility,
} from './ability'
```

## Verification

After completing all tasks, verify the implementation:

- [ ] **Dependencies installed**: Run `npm list @casl/ability @casl/react jwt-decode` in `apps/admin` to confirm packages installed
- [ ] **TypeScript compiles**: Run `cd apps/admin && npx tsc --noEmit` - should have no errors
- [ ] **Files created**: Verify all files exist:
  - `apps/admin/src/lib/permissions/roles.ts`
  - `apps/admin/src/lib/permissions/matrix.ts`
  - `apps/admin/src/lib/permissions/ability.ts`
  - `apps/admin/src/lib/permissions/index.ts`
  - `apps/admin/src/hooks/use-permissions.ts`
  - `apps/admin/src/components/providers/permission-provider.tsx`
- [ ] **Permission matrix matches requirements**: Manually verify matrix against requirements table
- [ ] **Role mapping works**: Database role `admin` maps to `Admin`, `client` to `Client`, `inspector`/`manager` to `Tech`

## Rollback

If the implementation needs to be reverted:

1. Remove installed packages:
   ```bash
   cd apps/admin && npm uninstall @casl/ability @casl/react jwt-decode
   ```

2. Delete created files:
   ```bash
   rm -rf apps/admin/src/lib/permissions
   rm apps/admin/src/hooks/use-permissions.ts
   rm apps/admin/src/components/providers/permission-provider.tsx
   ```

3. The existing auth system continues to work without permission infrastructure.

## Notes

- The permission matrix is defined as a static configuration for simplicity. If dynamic permissions are needed later, the matrix can be loaded from the database.
- The CASL library provides the ability to define complex permission rules. This implementation keeps it simple with page-level access control.
- The `jwt-decode` package is included for future use extracting role from JWT claims, though currently we read role from the profile fetched from the database.
- Client role users should typically be redirected to `/portal` routes which have separate routing.
