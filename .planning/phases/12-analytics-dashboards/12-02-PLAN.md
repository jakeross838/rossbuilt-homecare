# Plan 12-02: Dashboard Hooks

## Objective

Create React Query hooks for fetching dashboard metrics and analytics data. These hooks aggregate data from existing tables (inspections, work_orders, invoices, clients, properties) and provide computed metrics for dashboard visualizations.

## Dependencies

- 12-01: Analytics types, constants, and helper functions
- Existing hooks: use-clients.ts, use-properties.ts, use-inspections.ts, use-work-orders.ts, use-invoices.ts
- Supabase client for data fetching

## Constraints

- All queries must filter by organization_id (enforced by RLS)
- Use existing query patterns (queryKey factory, React Query)
- Handle loading/error states gracefully
- Support time period filtering for trend comparisons
- Minimize database queries by batching where possible

## Tasks

### Task 1: Dashboard Overview Hook

Create `apps/admin/src/hooks/use-dashboard-overview.ts`:

```typescript
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import type {
  TimePeriod,
  DashboardOverview,
  MetricWithTrend,
} from '@/lib/types/analytics'
import {
  getDateRangeForPeriod,
  getPreviousPeriodRange,
  calculateTrend,
} from '@/lib/helpers/analytics'

export const dashboardKeys = {
  all: ['dashboard'] as const,
  overview: (period: TimePeriod) => [...dashboardKeys.all, 'overview', period] as const,
  activity: () => [...dashboardKeys.all, 'activity'] as const,
  upcoming: () => [...dashboardKeys.all, 'upcoming'] as const,
  overdue: () => [...dashboardKeys.all, 'overdue'] as const,
}

interface UseOverviewOptions {
  period?: TimePeriod
}

/**
 * Hook to fetch dashboard overview metrics with trends
 */
export function useDashboardOverview(options: UseOverviewOptions = {}) {
  const { period = 'month' } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: dashboardKeys.overview(period),
    queryFn: async (): Promise<DashboardOverview> => {
      const orgId = profile!.organization_id
      const currentRange = getDateRangeForPeriod(period)
      const previousRange = getPreviousPeriodRange(period)

      // Fetch all counts in parallel
      const [
        currentClientsResult,
        previousClientsResult,
        currentPropertiesResult,
        previousPropertiesResult,
        currentInspectionsResult,
        previousInspectionsResult,
        currentWorkOrdersResult,
        previousWorkOrdersResult,
        currentRevenueResult,
        previousRevenueResult,
        outstandingResult,
      ] = await Promise.all([
        // Current period clients
        supabase
          .from('clients')
          .select('id', { count: 'exact', head: true })
          .eq('organization_id', orgId)
          .eq('is_active', true),
        // Previous period clients (use created_at for new clients)
        supabase
          .from('clients')
          .select('id', { count: 'exact', head: true })
          .eq('organization_id', orgId)
          .eq('is_active', true)
          .lt('created_at', currentRange.start.toISOString()),
        // Current properties
        supabase
          .from('properties')
          .select('id', { count: 'exact', head: true })
          .eq('organization_id', orgId)
          .eq('is_active', true),
        // Previous properties
        supabase
          .from('properties')
          .select('id', { count: 'exact', head: true })
          .eq('organization_id', orgId)
          .eq('is_active', true)
          .lt('created_at', currentRange.start.toISOString()),
        // Current period completed inspections
        supabase
          .from('inspections')
          .select('id', { count: 'exact', head: true })
          .eq('organization_id', orgId)
          .eq('status', 'completed')
          .gte('completed_at', currentRange.start.toISOString())
          .lte('completed_at', currentRange.end.toISOString()),
        // Previous period completed inspections
        supabase
          .from('inspections')
          .select('id', { count: 'exact', head: true })
          .eq('organization_id', orgId)
          .eq('status', 'completed')
          .gte('completed_at', previousRange.start.toISOString())
          .lte('completed_at', previousRange.end.toISOString()),
        // Current open work orders
        supabase
          .from('work_orders')
          .select('id', { count: 'exact', head: true })
          .eq('organization_id', orgId)
          .not('status', 'in', '("completed","cancelled")'),
        // Previous open work orders
        supabase
          .from('work_orders')
          .select('id', { count: 'exact', head: true })
          .eq('organization_id', orgId)
          .not('status', 'in', '("completed","cancelled")')
          .lt('created_at', currentRange.start.toISOString()),
        // Current period revenue (paid invoices)
        supabase
          .from('invoices')
          .select('total')
          .eq('organization_id', orgId)
          .eq('status', 'paid')
          .gte('paid_at', currentRange.start.toISOString())
          .lte('paid_at', currentRange.end.toISOString()),
        // Previous period revenue
        supabase
          .from('invoices')
          .select('total')
          .eq('organization_id', orgId)
          .eq('status', 'paid')
          .gte('paid_at', previousRange.start.toISOString())
          .lte('paid_at', previousRange.end.toISOString()),
        // Outstanding balance (sent, viewed, overdue, partial)
        supabase
          .from('invoices')
          .select('balance_due')
          .eq('organization_id', orgId)
          .in('status', ['sent', 'viewed', 'overdue', 'partial']),
      ])

      // Calculate totals
      const currentClients = currentClientsResult.count || 0
      const previousClients = previousClientsResult.count || 0
      const currentProperties = currentPropertiesResult.count || 0
      const previousProperties = previousPropertiesResult.count || 0
      const currentInspections = currentInspectionsResult.count || 0
      const previousInspections = previousInspectionsResult.count || 0
      const currentWorkOrders = currentWorkOrdersResult.count || 0
      const previousWorkOrders = previousWorkOrdersResult.count || 0

      const currentRevenue = (currentRevenueResult.data || [])
        .reduce((sum, inv) => sum + (inv.total || 0), 0)
      const previousRevenue = (previousRevenueResult.data || [])
        .reduce((sum, inv) => sum + (inv.total || 0), 0)
      const outstandingBalance = (outstandingResult.data || [])
        .reduce((sum, inv) => sum + (inv.balance_due || 0), 0)

      return {
        activeClients: calculateTrend(currentClients, previousClients),
        activeProperties: calculateTrend(currentProperties, previousProperties),
        inspectionsCompleted: calculateTrend(currentInspections, previousInspections),
        openWorkOrders: calculateTrend(currentWorkOrders, previousWorkOrders),
        revenue: calculateTrend(currentRevenue, previousRevenue),
        outstandingBalance,
      }
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000, // 5 minutes
  })
}
```

### Task 2: Inspection Metrics Hook

Create `apps/admin/src/hooks/use-inspection-metrics.ts`:

```typescript
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import type {
  TimePeriod,
  InspectionMetrics,
  TimeSeriesDataPoint,
  CategoryDataPoint,
} from '@/lib/types/analytics'
import {
  getDateRangeForPeriod,
  groupByDate,
  groupByCategory,
  fillDateGaps,
  calculateCompletionRate,
} from '@/lib/helpers/analytics'
import {
  STATUS_CHART_COLORS,
  TIER_CHART_COLORS,
} from '@/lib/constants/analytics'

export const inspectionMetricKeys = {
  all: ['inspection-metrics'] as const,
  summary: (period: TimePeriod) => [...inspectionMetricKeys.all, 'summary', period] as const,
  timeline: (period: TimePeriod) => [...inspectionMetricKeys.all, 'timeline', period] as const,
  byStatus: (period: TimePeriod) => [...inspectionMetricKeys.all, 'by-status', period] as const,
  byTier: (period: TimePeriod) => [...inspectionMetricKeys.all, 'by-tier', period] as const,
}

interface UseInspectionMetricsOptions {
  period?: TimePeriod
}

/**
 * Hook to fetch inspection metrics summary
 */
export function useInspectionMetrics(options: UseInspectionMetricsOptions = {}) {
  const { period = 'month' } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: inspectionMetricKeys.summary(period),
    queryFn: async (): Promise<InspectionMetrics> => {
      const orgId = profile!.organization_id
      const range = getDateRangeForPeriod(period)

      const { data: inspections, error } = await supabase
        .from('inspections')
        .select(`
          id,
          status,
          tier,
          scheduled_date,
          started_at,
          completed_at,
          findings
        `)
        .eq('organization_id', orgId)
        .gte('scheduled_date', range.start.toISOString())
        .lte('scheduled_date', range.end.toISOString())

      if (error) throw error

      const data = inspections || []
      const total = data.length
      const completed = data.filter((i) => i.status === 'completed').length

      // Count by status
      const byStatus = data.reduce((acc, i) => {
        acc[i.status] = (acc[i.status] || 0) + 1
        return acc
      }, {} as Record<string, number>)

      // Count by tier
      const byTier = data.reduce((acc, i) => {
        acc[i.tier] = (acc[i.tier] || 0) + 1
        return acc
      }, {} as Record<string, number>)

      // Calculate average duration (completed inspections only)
      const completedWithTimes = data.filter(
        (i) => i.status === 'completed' && i.started_at && i.completed_at
      )
      let averageDuration = 0
      if (completedWithTimes.length > 0) {
        const totalMinutes = completedWithTimes.reduce((sum, i) => {
          const start = new Date(i.started_at!).getTime()
          const end = new Date(i.completed_at!).getTime()
          return sum + (end - start) / 60000 // Convert to minutes
        }, 0)
        averageDuration = Math.round(totalMinutes / completedWithTimes.length)
      }

      // Aggregate findings from JSONB (findings is an array of finding objects)
      const findingsBreakdown = { pass: 0, fail: 0, needsAttention: 0, urgent: 0 }
      data.forEach((i) => {
        if (i.findings && Array.isArray(i.findings)) {
          (i.findings as { status: string }[]).forEach((f) => {
            if (f.status === 'pass') findingsBreakdown.pass++
            else if (f.status === 'fail') findingsBreakdown.fail++
            else if (f.status === 'needs_attention') findingsBreakdown.needsAttention++
            else if (f.status === 'urgent') findingsBreakdown.urgent++
          })
        }
      })

      return {
        total,
        byStatus,
        byTier,
        completionRate: calculateCompletionRate(completed, total),
        averageDuration,
        findingsBreakdown,
      }
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000,
  })
}

/**
 * Hook to fetch inspection timeline for charts
 */
export function useInspectionTimeline(options: UseInspectionMetricsOptions = {}) {
  const { period = 'month' } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: inspectionMetricKeys.timeline(period),
    queryFn: async (): Promise<TimeSeriesDataPoint[]> => {
      const orgId = profile!.organization_id
      const range = getDateRangeForPeriod(period)

      const { data, error } = await supabase
        .from('inspections')
        .select('id, scheduled_date, status')
        .eq('organization_id', orgId)
        .eq('status', 'completed')
        .gte('scheduled_date', range.start.toISOString())
        .lte('scheduled_date', range.end.toISOString())

      if (error) throw error

      const grouped = groupByDate(data || [], (i) => i.scheduled_date)
      return fillDateGaps(grouped, range.start, range.end)
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000,
  })
}

/**
 * Hook to fetch inspection distribution by status for pie chart
 */
export function useInspectionsByStatus(options: UseInspectionMetricsOptions = {}) {
  const { period = 'month' } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: inspectionMetricKeys.byStatus(period),
    queryFn: async (): Promise<CategoryDataPoint[]> => {
      const orgId = profile!.organization_id
      const range = getDateRangeForPeriod(period)

      const { data, error } = await supabase
        .from('inspections')
        .select('id, status')
        .eq('organization_id', orgId)
        .gte('scheduled_date', range.start.toISOString())
        .lte('scheduled_date', range.end.toISOString())

      if (error) throw error

      return groupByCategory(data || [], (i) => i.status, STATUS_CHART_COLORS)
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000,
  })
}

/**
 * Hook to fetch inspection distribution by tier for pie chart
 */
export function useInspectionsByTier(options: UseInspectionMetricsOptions = {}) {
  const { period = 'month' } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: inspectionMetricKeys.byTier(period),
    queryFn: async (): Promise<CategoryDataPoint[]> => {
      const orgId = profile!.organization_id
      const range = getDateRangeForPeriod(period)

      const { data, error } = await supabase
        .from('inspections')
        .select('id, tier')
        .eq('organization_id', orgId)
        .gte('scheduled_date', range.start.toISOString())
        .lte('scheduled_date', range.end.toISOString())

      if (error) throw error

      return groupByCategory(data || [], (i) => i.tier, TIER_CHART_COLORS)
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000,
  })
}
```

### Task 3: Work Order Metrics Hook

Create `apps/admin/src/hooks/use-work-order-metrics.ts`:

```typescript
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import type {
  TimePeriod,
  WorkOrderMetrics,
  VendorPerformanceMetric,
  TimeSeriesDataPoint,
  CategoryDataPoint,
} from '@/lib/types/analytics'
import {
  getDateRangeForPeriod,
  groupByDate,
  groupByCategory,
  fillDateGaps,
} from '@/lib/helpers/analytics'
import {
  STATUS_CHART_COLORS,
  PRIORITY_CHART_COLORS,
} from '@/lib/constants/analytics'

export const workOrderMetricKeys = {
  all: ['work-order-metrics'] as const,
  summary: (period: TimePeriod) => [...workOrderMetricKeys.all, 'summary', period] as const,
  timeline: (period: TimePeriod) => [...workOrderMetricKeys.all, 'timeline', period] as const,
  byStatus: (period: TimePeriod) => [...workOrderMetricKeys.all, 'by-status', period] as const,
  byCategory: (period: TimePeriod) => [...workOrderMetricKeys.all, 'by-category', period] as const,
  vendorPerformance: (period: TimePeriod) => [...workOrderMetricKeys.all, 'vendor-perf', period] as const,
}

interface UseWorkOrderMetricsOptions {
  period?: TimePeriod
}

/**
 * Hook to fetch work order metrics summary
 */
export function useWorkOrderMetrics(options: UseWorkOrderMetricsOptions = {}) {
  const { period = 'month' } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: workOrderMetricKeys.summary(period),
    queryFn: async (): Promise<WorkOrderMetrics> => {
      const orgId = profile!.organization_id
      const range = getDateRangeForPeriod(period)

      const { data: workOrders, error } = await supabase
        .from('work_orders')
        .select(`
          id,
          status,
          priority,
          category,
          actual_cost,
          created_at,
          completed_at,
          vendor:vendors(id, company_name, rating)
        `)
        .eq('organization_id', orgId)
        .gte('created_at', range.start.toISOString())
        .lte('created_at', range.end.toISOString())

      if (error) throw error

      const data = workOrders || []
      const total = data.length

      // Count by status
      const byStatus = data.reduce((acc, wo) => {
        acc[wo.status] = (acc[wo.status] || 0) + 1
        return acc
      }, {} as Record<string, number>)

      // Count by priority
      const byPriority = data.reduce((acc, wo) => {
        acc[wo.priority] = (acc[wo.priority] || 0) + 1
        return acc
      }, {} as Record<string, number>)

      // Count by category
      const byCategory = data.reduce((acc, wo) => {
        acc[wo.category] = (acc[wo.category] || 0) + 1
        return acc
      }, {} as Record<string, number>)

      // Calculate average completion time (in days)
      const completedOrders = data.filter(
        (wo) => wo.status === 'completed' && wo.completed_at
      )
      let averageCompletionTime = 0
      if (completedOrders.length > 0) {
        const totalDays = completedOrders.reduce((sum, wo) => {
          const created = new Date(wo.created_at).getTime()
          const completed = new Date(wo.completed_at!).getTime()
          return sum + (completed - created) / (1000 * 60 * 60 * 24)
        }, 0)
        averageCompletionTime = Math.round(totalDays / completedOrders.length)
      }

      // Total cost
      const totalCost = data.reduce((sum, wo) => sum + (wo.actual_cost || 0), 0)

      // Vendor performance (aggregate by vendor)
      const vendorMap = new Map<string, VendorPerformanceMetric>()
      data.forEach((wo) => {
        if (wo.vendor) {
          const vendor = wo.vendor as { id: string; company_name: string; rating: number }
          const existing = vendorMap.get(vendor.id)
          if (existing) {
            if (wo.status === 'completed') existing.completedJobs++
            existing.totalRevenue += wo.actual_cost || 0
          } else {
            vendorMap.set(vendor.id, {
              vendorId: vendor.id,
              vendorName: vendor.company_name,
              completedJobs: wo.status === 'completed' ? 1 : 0,
              averageRating: vendor.rating || 0,
              totalRevenue: wo.actual_cost || 0,
            })
          }
        }
      })
      const vendorPerformance = Array.from(vendorMap.values())
        .sort((a, b) => b.completedJobs - a.completedJobs)
        .slice(0, 10) // Top 10 vendors

      return {
        total,
        byStatus,
        byPriority,
        byCategory,
        averageCompletionTime,
        totalCost,
        vendorPerformance,
      }
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000,
  })
}

/**
 * Hook to fetch work order timeline for charts
 */
export function useWorkOrderTimeline(options: UseWorkOrderMetricsOptions = {}) {
  const { period = 'month' } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: workOrderMetricKeys.timeline(period),
    queryFn: async (): Promise<TimeSeriesDataPoint[]> => {
      const orgId = profile!.organization_id
      const range = getDateRangeForPeriod(period)

      const { data, error } = await supabase
        .from('work_orders')
        .select('id, created_at')
        .eq('organization_id', orgId)
        .gte('created_at', range.start.toISOString())
        .lte('created_at', range.end.toISOString())

      if (error) throw error

      const grouped = groupByDate(data || [], (wo) => wo.created_at)
      return fillDateGaps(grouped, range.start, range.end)
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000,
  })
}

/**
 * Hook to fetch work orders by status for pie chart
 */
export function useWorkOrdersByStatus(options: UseWorkOrderMetricsOptions = {}) {
  const { period = 'month' } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: workOrderMetricKeys.byStatus(period),
    queryFn: async (): Promise<CategoryDataPoint[]> => {
      const orgId = profile!.organization_id
      const range = getDateRangeForPeriod(period)

      const { data, error } = await supabase
        .from('work_orders')
        .select('id, status')
        .eq('organization_id', orgId)
        .gte('created_at', range.start.toISOString())
        .lte('created_at', range.end.toISOString())

      if (error) throw error

      return groupByCategory(data || [], (wo) => wo.status, STATUS_CHART_COLORS)
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000,
  })
}

/**
 * Hook to fetch work orders by category for bar chart
 */
export function useWorkOrdersByCategory(options: UseWorkOrderMetricsOptions = {}) {
  const { period = 'month' } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: workOrderMetricKeys.byCategory(period),
    queryFn: async (): Promise<CategoryDataPoint[]> => {
      const orgId = profile!.organization_id
      const range = getDateRangeForPeriod(period)

      const { data, error } = await supabase
        .from('work_orders')
        .select('id, category')
        .eq('organization_id', orgId)
        .gte('created_at', range.start.toISOString())
        .lte('created_at', range.end.toISOString())

      if (error) throw error

      return groupByCategory(data || [], (wo) => wo.category)
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000,
  })
}
```

### Task 4: Revenue Metrics Hook

Create `apps/admin/src/hooks/use-revenue-metrics.ts`:

```typescript
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import type {
  TimePeriod,
  RevenueMetrics,
  MonthlyRevenue,
  ClientRevenue,
  TimeSeriesDataPoint,
  CategoryDataPoint,
} from '@/lib/types/analytics'
import {
  getDateRangeForPeriod,
  aggregateMonthly,
  groupByDate,
  fillDateGaps,
  sortByValue,
} from '@/lib/helpers/analytics'
import { STATUS_CHART_COLORS } from '@/lib/constants/analytics'

export const revenueMetricKeys = {
  all: ['revenue-metrics'] as const,
  summary: (period: TimePeriod) => [...revenueMetricKeys.all, 'summary', period] as const,
  timeline: (period: TimePeriod) => [...revenueMetricKeys.all, 'timeline', period] as const,
  byClient: (period: TimePeriod) => [...revenueMetricKeys.all, 'by-client', period] as const,
  byStatus: (period: TimePeriod) => [...revenueMetricKeys.all, 'by-status', period] as const,
}

interface UseRevenueMetricsOptions {
  period?: TimePeriod
}

/**
 * Hook to fetch revenue metrics summary
 */
export function useRevenueMetrics(options: UseRevenueMetricsOptions = {}) {
  const { period = 'month' } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: revenueMetricKeys.summary(period),
    queryFn: async (): Promise<RevenueMetrics> => {
      const orgId = profile!.organization_id
      const range = getDateRangeForPeriod(period)

      // Fetch paid invoices in period
      const { data: paidInvoices, error: paidError } = await supabase
        .from('invoices')
        .select(`
          id,
          invoice_type,
          total,
          paid_at,
          client_id,
          client:clients(id, first_name, last_name, company_name)
        `)
        .eq('organization_id', orgId)
        .eq('status', 'paid')
        .gte('paid_at', range.start.toISOString())
        .lte('paid_at', range.end.toISOString())

      if (paidError) throw paidError

      // Fetch outstanding invoices
      const { data: outstandingInvoices, error: outError } = await supabase
        .from('invoices')
        .select('id, balance_due, due_date, status')
        .eq('organization_id', orgId)
        .in('status', ['sent', 'viewed', 'partial', 'overdue'])

      if (outError) throw outError

      const paid = paidInvoices || []
      const outstanding = outstandingInvoices || []

      // Calculate total revenue
      const totalRevenue = paid.reduce((sum, inv) => sum + (inv.total || 0), 0)

      // Split by type
      const recurringRevenue = paid
        .filter((inv) => inv.invoice_type === 'subscription')
        .reduce((sum, inv) => sum + (inv.total || 0), 0)
      const serviceRevenue = totalRevenue - recurringRevenue

      // Group by month
      const monthlyData = groupByDate(paid, (inv) => inv.paid_at!, (inv) => inv.total || 0)
      const byMonth: MonthlyRevenue[] = aggregateMonthly(monthlyData).map((point) => ({
        month: point.date,
        revenue: point.value,
        invoiceCount: paid.filter((inv) => inv.paid_at?.startsWith(point.date)).length,
      }))

      // Group by client
      const clientMap = new Map<string, ClientRevenue>()
      paid.forEach((inv) => {
        if (inv.client) {
          const client = inv.client as { id: string; first_name: string; last_name: string; company_name?: string }
          const existing = clientMap.get(client.id)
          if (existing) {
            existing.totalRevenue += inv.total || 0
          } else {
            clientMap.set(client.id, {
              clientId: client.id,
              clientName: client.company_name || `${client.first_name} ${client.last_name}`,
              totalRevenue: inv.total || 0,
              propertyCount: 1, // Would need additional query for accurate count
            })
          }
        }
      })
      const byClient = Array.from(clientMap.values())
        .sort((a, b) => b.totalRevenue - a.totalRevenue)
        .slice(0, 10)

      // Outstanding totals
      const outstandingTotal = outstanding.reduce((sum, inv) => sum + (inv.balance_due || 0), 0)
      const today = new Date().toISOString().split('T')[0]
      const overdueAmount = outstanding
        .filter((inv) => inv.due_date && inv.due_date < today)
        .reduce((sum, inv) => sum + (inv.balance_due || 0), 0)

      return {
        totalRevenue,
        recurringRevenue,
        serviceRevenue,
        byMonth,
        byClient,
        outstandingInvoices: outstandingTotal,
        overdueAmount,
      }
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000,
  })
}

/**
 * Hook to fetch revenue timeline for charts
 */
export function useRevenueTimeline(options: UseRevenueMetricsOptions = {}) {
  const { period = 'month' } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: revenueMetricKeys.timeline(period),
    queryFn: async (): Promise<TimeSeriesDataPoint[]> => {
      const orgId = profile!.organization_id
      const range = getDateRangeForPeriod(period)

      const { data, error } = await supabase
        .from('invoices')
        .select('id, paid_at, total')
        .eq('organization_id', orgId)
        .eq('status', 'paid')
        .gte('paid_at', range.start.toISOString())
        .lte('paid_at', range.end.toISOString())

      if (error) throw error

      const grouped = groupByDate(
        data || [],
        (inv) => inv.paid_at!,
        (inv) => inv.total || 0
      )
      return fillDateGaps(grouped, range.start, range.end)
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000,
  })
}

/**
 * Hook to fetch invoices by status for pie chart
 */
export function useInvoicesByStatus(options: UseRevenueMetricsOptions = {}) {
  const { period = 'month' } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: revenueMetricKeys.byStatus(period),
    queryFn: async (): Promise<CategoryDataPoint[]> => {
      const orgId = profile!.organization_id
      const range = getDateRangeForPeriod(period)

      const { data, error } = await supabase
        .from('invoices')
        .select('id, status')
        .eq('organization_id', orgId)
        .gte('invoice_date', range.start.toISOString())
        .lte('invoice_date', range.end.toISOString())

      if (error) throw error

      return sortByValue(
        (data || []).reduce((acc, inv) => {
          const existing = acc.find((c) => c.name === inv.status)
          if (existing) {
            existing.value++
          } else {
            acc.push({
              name: inv.status,
              value: 1,
              color: STATUS_CHART_COLORS[inv.status],
            })
          }
          return acc
        }, [] as CategoryDataPoint[])
      )
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000,
  })
}
```

### Task 5: Activity and Alerts Hook

Create `apps/admin/src/hooks/use-dashboard-activity.ts`:

```typescript
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import type {
  ActivityLogEntry,
  UpcomingInspection,
  OverdueItem,
} from '@/lib/types/analytics'
import { dashboardKeys } from './use-dashboard-overview'

/**
 * Hook to fetch recent activity for activity feed
 */
export function useRecentActivity(limit: number = 10) {
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: [...dashboardKeys.activity(), limit],
    queryFn: async (): Promise<ActivityLogEntry[]> => {
      const orgId = profile!.organization_id
      const activities: ActivityLogEntry[] = []

      // Fetch recent inspections
      const { data: inspections } = await supabase
        .from('inspections')
        .select(`
          id,
          status,
          updated_at,
          property:properties(name),
          inspector:users(first_name, last_name)
        `)
        .eq('organization_id', orgId)
        .order('updated_at', { ascending: false })
        .limit(5)

      inspections?.forEach((insp) => {
        const property = insp.property as { name: string } | null
        const inspector = insp.inspector as { first_name: string; last_name: string } | null
        activities.push({
          id: `inspection-${insp.id}`,
          type: 'inspection',
          action: insp.status === 'completed' ? 'completed' : 'updated',
          title: insp.status === 'completed' ? 'Inspection completed' : 'Inspection updated',
          description: property?.name || 'Unknown property',
          entityId: insp.id,
          userName: inspector ? `${inspector.first_name} ${inspector.last_name}` : undefined,
          timestamp: insp.updated_at,
        })
      })

      // Fetch recent work orders
      const { data: workOrders } = await supabase
        .from('work_orders')
        .select(`
          id,
          work_order_number,
          status,
          title,
          updated_at,
          property:properties(name)
        `)
        .eq('organization_id', orgId)
        .order('updated_at', { ascending: false })
        .limit(5)

      workOrders?.forEach((wo) => {
        const property = wo.property as { name: string } | null
        activities.push({
          id: `work-order-${wo.id}`,
          type: 'work_order',
          action: wo.status === 'completed' ? 'completed' : 'updated',
          title: wo.status === 'completed' ? 'Work order completed' : `Work order ${wo.status.replace('_', ' ')}`,
          description: wo.title || property?.name || wo.work_order_number,
          entityId: wo.id,
          timestamp: wo.updated_at,
        })
      })

      // Fetch recent invoices
      const { data: invoices } = await supabase
        .from('invoices')
        .select(`
          id,
          invoice_number,
          status,
          total,
          updated_at,
          client:clients(first_name, last_name, company_name)
        `)
        .eq('organization_id', orgId)
        .order('updated_at', { ascending: false })
        .limit(5)

      invoices?.forEach((inv) => {
        const client = inv.client as { first_name: string; last_name: string; company_name?: string } | null
        const clientName = client?.company_name || (client ? `${client.first_name} ${client.last_name}` : 'Unknown')
        activities.push({
          id: `invoice-${inv.id}`,
          type: 'invoice',
          action: inv.status === 'paid' ? 'paid' : 'updated',
          title: inv.status === 'paid' ? 'Invoice paid' : `Invoice ${inv.status}`,
          description: `${inv.invoice_number} - ${clientName}`,
          entityId: inv.id,
          timestamp: inv.updated_at,
        })
      })

      // Sort by timestamp and take limit
      return activities
        .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
        .slice(0, limit)
    },
    enabled: !!profile?.organization_id,
    staleTime: 60 * 1000, // 1 minute
  })
}

/**
 * Hook to fetch upcoming inspections
 */
export function useUpcomingInspections(days: number = 7, limit: number = 5) {
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: [...dashboardKeys.upcoming(), days, limit],
    queryFn: async (): Promise<UpcomingInspection[]> => {
      const orgId = profile!.organization_id
      const today = new Date()
      const endDate = new Date()
      endDate.setDate(today.getDate() + days)

      const { data, error } = await supabase
        .from('inspections')
        .select(`
          id,
          scheduled_date,
          tier,
          property:properties(name),
          client:properties(client:clients(first_name, last_name, company_name)),
          inspector:users(first_name, last_name)
        `)
        .eq('organization_id', orgId)
        .in('status', ['scheduled', 'rescheduled'])
        .gte('scheduled_date', today.toISOString())
        .lte('scheduled_date', endDate.toISOString())
        .order('scheduled_date', { ascending: true })
        .limit(limit)

      if (error) throw error

      return (data || []).map((insp) => {
        const property = insp.property as { name: string } | null
        const clientData = insp.client as { client: { first_name: string; last_name: string; company_name?: string } } | null
        const inspector = insp.inspector as { first_name: string; last_name: string } | null
        const client = clientData?.client

        return {
          id: insp.id,
          propertyName: property?.name || 'Unknown property',
          clientName: client?.company_name || (client ? `${client.first_name} ${client.last_name}` : 'Unknown'),
          scheduledDate: insp.scheduled_date,
          tier: insp.tier,
          inspectorName: inspector ? `${inspector.first_name} ${inspector.last_name}` : undefined,
        }
      })
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000,
  })
}

/**
 * Hook to fetch overdue items requiring attention
 */
export function useOverdueItems() {
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: dashboardKeys.overdue(),
    queryFn: async (): Promise<OverdueItem[]> => {
      const orgId = profile!.organization_id
      const today = new Date().toISOString().split('T')[0]
      const items: OverdueItem[] = []

      // Overdue inspections (scheduled in past, not completed)
      const { data: inspections } = await supabase
        .from('inspections')
        .select('id, scheduled_date, property:properties(name)')
        .eq('organization_id', orgId)
        .in('status', ['scheduled', 'rescheduled'])
        .lt('scheduled_date', today)
        .limit(10)

      inspections?.forEach((insp) => {
        const property = insp.property as { name: string } | null
        const scheduledDate = new Date(insp.scheduled_date)
        const daysOverdue = Math.floor((Date.now() - scheduledDate.getTime()) / (1000 * 60 * 60 * 24))
        items.push({
          type: 'inspection',
          id: insp.id,
          title: property?.name || 'Unknown property',
          dueDate: insp.scheduled_date,
          daysOverdue,
          priority: daysOverdue > 7 ? 'high' : daysOverdue > 3 ? 'medium' : 'low',
        })
      })

      // Overdue work orders (past scheduled completion)
      const { data: workOrders } = await supabase
        .from('work_orders')
        .select('id, title, scheduled_completion_date, priority')
        .eq('organization_id', orgId)
        .not('status', 'in', '("completed","cancelled")')
        .lt('scheduled_completion_date', today)
        .limit(10)

      workOrders?.forEach((wo) => {
        const dueDate = new Date(wo.scheduled_completion_date)
        const daysOverdue = Math.floor((Date.now() - dueDate.getTime()) / (1000 * 60 * 60 * 24))
        items.push({
          type: 'work_order',
          id: wo.id,
          title: wo.title,
          dueDate: wo.scheduled_completion_date,
          daysOverdue,
          priority: wo.priority as 'low' | 'medium' | 'high' | 'urgent',
        })
      })

      // Overdue invoices
      const { data: invoices } = await supabase
        .from('invoices')
        .select('id, invoice_number, due_date, client:clients(first_name, last_name)')
        .eq('organization_id', orgId)
        .in('status', ['sent', 'viewed', 'partial'])
        .lt('due_date', today)
        .limit(10)

      invoices?.forEach((inv) => {
        const client = inv.client as { first_name: string; last_name: string } | null
        const dueDate = new Date(inv.due_date)
        const daysOverdue = Math.floor((Date.now() - dueDate.getTime()) / (1000 * 60 * 60 * 24))
        items.push({
          type: 'invoice',
          id: inv.id,
          title: `${inv.invoice_number} - ${client ? `${client.first_name} ${client.last_name}` : 'Unknown'}`,
          dueDate: inv.due_date,
          daysOverdue,
          priority: daysOverdue > 30 ? 'urgent' : daysOverdue > 14 ? 'high' : daysOverdue > 7 ? 'medium' : 'low',
        })
      })

      // Sort by days overdue (most urgent first)
      return items.sort((a, b) => b.daysOverdue - a.daysOverdue)
    },
    enabled: !!profile?.organization_id,
    staleTime: 5 * 60 * 1000,
  })
}
```

## Verification

After completing all tasks, verify:

1. **Types compile**: `cd apps/admin && npx tsc --noEmit`
2. **Files exist**:
   - `apps/admin/src/hooks/use-dashboard-overview.ts`
   - `apps/admin/src/hooks/use-inspection-metrics.ts`
   - `apps/admin/src/hooks/use-work-order-metrics.ts`
   - `apps/admin/src/hooks/use-revenue-metrics.ts`
   - `apps/admin/src/hooks/use-dashboard-activity.ts`
3. **Hooks export correctly**: All hooks can be imported and used

## Commit

```
feat(analytics): add dashboard data hooks

- Add overview metrics hook with trend comparisons
- Add inspection metrics hooks (summary, timeline, distribution)
- Add work order metrics hooks with vendor performance
- Add revenue metrics hooks with monthly breakdown
- Add activity feed and overdue items hooks
```
