# Plan 12-01: Analytics Data Foundation

## Objective

Create TypeScript types, constants, and helper functions for analytics and dashboard metrics. This establishes the data layer for aggregating operational metrics across inspections, work orders, revenue, and client/property health.

## Dependencies

- Existing hooks: use-inspections.ts, use-work-orders.ts, use-invoices.ts, use-clients.ts, use-properties.ts
- Database tables: inspections, work_orders, invoices, clients, properties, programs
- Existing type patterns from lib/types/

## Constraints

- All analytics queries must respect organization_id filtering (RLS)
- Time periods should be configurable (today, week, month, quarter, year)
- Aggregations computed client-side for flexibility (Supabase RPC for heavy aggregations if needed)
- Must handle empty data gracefully (no chart errors with zero data)

## Tasks

### Task 1: Analytics TypeScript Types

Create `apps/admin/src/lib/types/analytics.ts`:

```typescript
/**
 * Analytics types for Home Care OS dashboards
 */

// Time period options for filtering
export type TimePeriod = 'today' | 'week' | 'month' | 'quarter' | 'year' | 'all'

// Date range for custom filtering
export interface DateRange {
  start: Date
  end: Date
}

// Generic metric with value and trend
export interface MetricWithTrend {
  current: number
  previous: number
  change: number // percentage change
  trend: 'up' | 'down' | 'flat'
}

// Overview metrics for main dashboard
export interface DashboardOverview {
  activeClients: MetricWithTrend
  activeProperties: MetricWithTrend
  inspectionsCompleted: MetricWithTrend
  openWorkOrders: MetricWithTrend
  revenue: MetricWithTrend
  outstandingBalance: number
}

// Inspection metrics
export interface InspectionMetrics {
  total: number
  byStatus: Record<string, number>
  byTier: Record<string, number>
  completionRate: number
  averageDuration: number // in minutes
  findingsBreakdown: {
    pass: number
    fail: number
    needsAttention: number
    urgent: number
  }
}

// Work order metrics
export interface WorkOrderMetrics {
  total: number
  byStatus: Record<string, number>
  byPriority: Record<string, number>
  byCategory: Record<string, number>
  averageCompletionTime: number // in days
  totalCost: number
  vendorPerformance: VendorPerformanceMetric[]
}

export interface VendorPerformanceMetric {
  vendorId: string
  vendorName: string
  completedJobs: number
  averageRating: number
  totalRevenue: number
}

// Revenue metrics
export interface RevenueMetrics {
  totalRevenue: number
  recurringRevenue: number // from programs
  serviceRevenue: number // from work orders
  byMonth: MonthlyRevenue[]
  byClient: ClientRevenue[]
  outstandingInvoices: number
  overdueAmount: number
}

export interface MonthlyRevenue {
  month: string // YYYY-MM format
  revenue: number
  invoiceCount: number
}

export interface ClientRevenue {
  clientId: string
  clientName: string
  totalRevenue: number
  propertyCount: number
}

// Property health metrics
export interface PropertyHealthMetrics {
  total: number
  excellent: number
  good: number
  needsAttention: number
  poor: number
  unassessed: number
  averageCondition: number // 1-5 scale
}

// Client engagement metrics
export interface ClientEngagementMetrics {
  totalClients: number
  activeClients: number // with active programs
  newClientsThisPeriod: number
  churnedClientsThisPeriod: number
  retentionRate: number
  averagePropertiesPerClient: number
}

// Activity log entry for recent activity feed
export interface ActivityLogEntry {
  id: string
  type: 'inspection' | 'work_order' | 'invoice' | 'client' | 'property' | 'service_request'
  action: 'created' | 'updated' | 'completed' | 'cancelled' | 'paid'
  title: string
  description: string
  entityId: string
  userId?: string
  userName?: string
  timestamp: string
}

// Chart data point for time series
export interface TimeSeriesDataPoint {
  date: string
  value: number
  label?: string
}

// Chart data for categorical data
export interface CategoryDataPoint {
  name: string
  value: number
  color?: string
}

// Inspector workload for scheduling optimization
export interface InspectorWorkloadMetric {
  inspectorId: string
  inspectorName: string
  scheduledInspections: number
  completedInspections: number
  averageRating: number
  utilizationRate: number // percentage
}

// Upcoming inspections for schedule overview
export interface UpcomingInspection {
  id: string
  propertyName: string
  clientName: string
  scheduledDate: string
  tier: string
  inspectorName?: string
}

// Overdue items requiring attention
export interface OverdueItem {
  type: 'inspection' | 'work_order' | 'invoice'
  id: string
  title: string
  dueDate: string
  daysOverdue: number
  priority: 'low' | 'medium' | 'high' | 'urgent'
}
```

### Task 2: Analytics Constants

Create `apps/admin/src/lib/constants/analytics.ts`:

```typescript
/**
 * Analytics constants for dashboards
 */

// Time period options with labels
export const TIME_PERIODS = [
  { value: 'today', label: 'Today' },
  { value: 'week', label: 'This Week' },
  { value: 'month', label: 'This Month' },
  { value: 'quarter', label: 'This Quarter' },
  { value: 'year', label: 'This Year' },
  { value: 'all', label: 'All Time' },
] as const

// Chart colors aligned with Ross Built brand
export const CHART_COLORS = {
  primary: '#16a34a', // rb-green-600
  secondary: '#d4a574', // rb-sand (approximate)
  accent: '#0ea5e9', // sky-500
  muted: '#94a3b8', // slate-400
  success: '#22c55e', // green-500
  warning: '#f59e0b', // amber-500
  danger: '#ef4444', // red-500
  info: '#3b82f6', // blue-500
} as const

// Status colors for charts
export const STATUS_CHART_COLORS: Record<string, string> = {
  // Inspection statuses
  scheduled: CHART_COLORS.info,
  in_progress: CHART_COLORS.warning,
  completed: CHART_COLORS.success,
  cancelled: CHART_COLORS.muted,
  rescheduled: CHART_COLORS.accent,
  // Work order statuses
  pending: CHART_COLORS.muted,
  vendor_assigned: CHART_COLORS.info,
  on_hold: CHART_COLORS.warning,
  // Invoice statuses
  draft: CHART_COLORS.muted,
  sent: CHART_COLORS.info,
  viewed: CHART_COLORS.accent,
  paid: CHART_COLORS.success,
  partial: CHART_COLORS.warning,
  overdue: CHART_COLORS.danger,
  void: CHART_COLORS.muted,
}

// Priority colors for charts
export const PRIORITY_CHART_COLORS: Record<string, string> = {
  low: '#94a3b8', // slate-400
  medium: '#3b82f6', // blue-500
  high: '#f59e0b', // amber-500
  urgent: '#ef4444', // red-500
}

// Condition colors for property health
export const CONDITION_CHART_COLORS: Record<string, string> = {
  excellent: '#22c55e', // green-500
  good: '#84cc16', // lime-500
  fair: '#f59e0b', // amber-500
  needs_attention: '#f97316', // orange-500
  poor: '#ef4444', // red-500
}

// Tier colors for inspection distribution
export const TIER_CHART_COLORS: Record<string, string> = {
  visual: '#94a3b8', // slate-400
  functional: '#3b82f6', // blue-500
  comprehensive: '#8b5cf6', // violet-500
  preventative: '#16a34a', // green-600
}

// Default date ranges in days
export const DATE_RANGE_DAYS: Record<string, number> = {
  today: 0,
  week: 7,
  month: 30,
  quarter: 90,
  year: 365,
  all: 3650, // ~10 years
}

// Dashboard refresh intervals (in milliseconds)
export const REFRESH_INTERVALS = {
  realtime: 30000, // 30 seconds
  frequent: 60000, // 1 minute
  normal: 300000, // 5 minutes
  lazy: 900000, // 15 minutes
} as const

// Metric thresholds for alerts
export const METRIC_THRESHOLDS = {
  completionRateWarning: 85, // Below this shows warning
  completionRateDanger: 70, // Below this shows danger
  overdueCountWarning: 5,
  overdueCountDanger: 10,
  utilizationOptimal: 80, // Ideal inspector utilization
  utilizationWarning: 95, // Too high
}

// Chart configuration defaults
export const CHART_DEFAULTS = {
  animationDuration: 300,
  tooltipDelay: 100,
  barRadius: 4,
  strokeWidth: 2,
  dotRadius: 4,
  activeDotRadius: 6,
}
```

### Task 3: Analytics Helper Functions

Create `apps/admin/src/lib/helpers/analytics.ts`:

```typescript
/**
 * Analytics helper functions for data aggregation and formatting
 */

import type {
  TimePeriod,
  DateRange,
  MetricWithTrend,
  TimeSeriesDataPoint,
  CategoryDataPoint,
} from '@/lib/types/analytics'
import { DATE_RANGE_DAYS } from '@/lib/constants/analytics'

/**
 * Get date range for a given time period
 */
export function getDateRangeForPeriod(period: TimePeriod): DateRange {
  const end = new Date()
  end.setHours(23, 59, 59, 999)

  const start = new Date()
  start.setHours(0, 0, 0, 0)

  if (period === 'today') {
    return { start, end }
  }

  const days = DATE_RANGE_DAYS[period] || 30
  start.setDate(start.getDate() - days)

  return { start, end }
}

/**
 * Get previous period date range for comparison
 */
export function getPreviousPeriodRange(period: TimePeriod): DateRange {
  const current = getDateRangeForPeriod(period)
  const duration = current.end.getTime() - current.start.getTime()

  const end = new Date(current.start.getTime() - 1)
  const start = new Date(end.getTime() - duration)

  return { start, end }
}

/**
 * Calculate metric with trend comparison
 */
export function calculateTrend(current: number, previous: number): MetricWithTrend {
  const change = previous === 0
    ? current > 0 ? 100 : 0
    : Math.round(((current - previous) / previous) * 100)

  return {
    current,
    previous,
    change,
    trend: change > 0 ? 'up' : change < 0 ? 'down' : 'flat',
  }
}

/**
 * Format large numbers with K/M/B suffixes
 */
export function formatCompactNumber(value: number): string {
  if (value >= 1_000_000_000) {
    return `${(value / 1_000_000_000).toFixed(1)}B`
  }
  if (value >= 1_000_000) {
    return `${(value / 1_000_000).toFixed(1)}M`
  }
  if (value >= 1_000) {
    return `${(value / 1_000).toFixed(1)}K`
  }
  return value.toString()
}

/**
 * Format currency for display
 */
export function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(amount)
}

/**
 * Format percentage with sign
 */
export function formatPercentageChange(change: number): string {
  const sign = change > 0 ? '+' : ''
  return `${sign}${change}%`
}

/**
 * Group data by date for time series charts
 */
export function groupByDate<T>(
  items: T[],
  dateAccessor: (item: T) => string,
  valueAccessor: (item: T) => number = () => 1
): TimeSeriesDataPoint[] {
  const grouped = items.reduce((acc, item) => {
    const date = dateAccessor(item).split('T')[0] // Get date part only
    acc[date] = (acc[date] || 0) + valueAccessor(item)
    return acc
  }, {} as Record<string, number>)

  return Object.entries(grouped)
    .map(([date, value]) => ({ date, value }))
    .sort((a, b) => a.date.localeCompare(b.date))
}

/**
 * Group data by category for pie/bar charts
 */
export function groupByCategory<T>(
  items: T[],
  categoryAccessor: (item: T) => string,
  colorMap?: Record<string, string>
): CategoryDataPoint[] {
  const grouped = items.reduce((acc, item) => {
    const category = categoryAccessor(item)
    acc[category] = (acc[category] || 0) + 1
    return acc
  }, {} as Record<string, number>)

  return Object.entries(grouped).map(([name, value]) => ({
    name,
    value,
    color: colorMap?.[name],
  }))
}

/**
 * Fill missing dates in time series with zero values
 */
export function fillDateGaps(
  data: TimeSeriesDataPoint[],
  startDate: Date,
  endDate: Date
): TimeSeriesDataPoint[] {
  const dateMap = new Map(data.map((d) => [d.date, d.value]))
  const result: TimeSeriesDataPoint[] = []

  const current = new Date(startDate)
  while (current <= endDate) {
    const dateStr = current.toISOString().split('T')[0]
    result.push({
      date: dateStr,
      value: dateMap.get(dateStr) || 0,
    })
    current.setDate(current.getDate() + 1)
  }

  return result
}

/**
 * Aggregate monthly data from daily data
 */
export function aggregateMonthly(data: TimeSeriesDataPoint[]): TimeSeriesDataPoint[] {
  const monthly = data.reduce((acc, point) => {
    const month = point.date.substring(0, 7) // YYYY-MM
    acc[month] = (acc[month] || 0) + point.value
    return acc
  }, {} as Record<string, number>)

  return Object.entries(monthly)
    .map(([date, value]) => ({ date, value }))
    .sort((a, b) => a.date.localeCompare(b.date))
}

/**
 * Calculate average from array of numbers
 */
export function calculateAverage(values: number[]): number {
  if (values.length === 0) return 0
  return Math.round(values.reduce((sum, v) => sum + v, 0) / values.length)
}

/**
 * Calculate completion rate
 */
export function calculateCompletionRate(completed: number, total: number): number {
  if (total === 0) return 0
  return Math.round((completed / total) * 100)
}

/**
 * Get friendly label for time period
 */
export function getPeriodLabel(period: TimePeriod): string {
  const labels: Record<TimePeriod, string> = {
    today: 'Today',
    week: 'This Week',
    month: 'This Month',
    quarter: 'This Quarter',
    year: 'This Year',
    all: 'All Time',
  }
  return labels[period]
}

/**
 * Get comparison label for previous period
 */
export function getComparisonLabel(period: TimePeriod): string {
  const labels: Record<TimePeriod, string> = {
    today: 'vs yesterday',
    week: 'vs last week',
    month: 'vs last month',
    quarter: 'vs last quarter',
    year: 'vs last year',
    all: '',
  }
  return labels[period]
}

/**
 * Determine trend indicator color
 */
export function getTrendColor(
  trend: 'up' | 'down' | 'flat',
  positiveIsGood: boolean = true
): string {
  if (trend === 'flat') return 'text-muted-foreground'
  const isPositive = trend === 'up'
  if (positiveIsGood) {
    return isPositive ? 'text-green-600' : 'text-red-600'
  }
  return isPositive ? 'text-red-600' : 'text-green-600'
}

/**
 * Sort category data by value (descending)
 */
export function sortByValue(data: CategoryDataPoint[]): CategoryDataPoint[] {
  return [...data].sort((a, b) => b.value - a.value)
}

/**
 * Take top N categories, grouping rest into "Other"
 */
export function takeTopCategories(
  data: CategoryDataPoint[],
  topN: number,
  otherLabel: string = 'Other'
): CategoryDataPoint[] {
  if (data.length <= topN) return data

  const sorted = sortByValue(data)
  const top = sorted.slice(0, topN)
  const otherValue = sorted.slice(topN).reduce((sum, d) => sum + d.value, 0)

  if (otherValue > 0) {
    top.push({ name: otherLabel, value: otherValue })
  }

  return top
}

/**
 * Format date for chart axis labels
 */
export function formatChartDate(dateStr: string, period: TimePeriod): string {
  const date = new Date(dateStr)

  if (period === 'today') {
    return date.toLocaleTimeString('en-US', { hour: 'numeric' })
  }

  if (period === 'week') {
    return date.toLocaleDateString('en-US', { weekday: 'short' })
  }

  if (period === 'month') {
    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
  }

  if (period === 'quarter' || period === 'year') {
    return date.toLocaleDateString('en-US', { month: 'short' })
  }

  return date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' })
}
```

## Verification

After completing all tasks, verify:

1. **Types compile**: `cd apps/admin && npx tsc --noEmit`
2. **Files exist**:
   - `apps/admin/src/lib/types/analytics.ts`
   - `apps/admin/src/lib/constants/analytics.ts`
   - `apps/admin/src/lib/helpers/analytics.ts`
3. **Imports work**: Test importing from each file

## Commit

```
feat(analytics): add analytics data foundation

- Add TypeScript types for dashboard metrics and charts
- Add analytics constants (colors, thresholds, time periods)
- Add helper functions for data aggregation and formatting
```
