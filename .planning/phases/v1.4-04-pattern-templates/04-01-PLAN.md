---
phase: v1.4-04-pattern-templates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/admin/src/hooks/use-base-query.ts
  - apps/admin/src/hooks/use-base-mutation.ts
  - apps/admin/src/hooks/index.ts
  - apps/admin/src/hooks/use-clients.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Base query hook provides standardized query pattern with realtime subscription"
    - "Base mutation hook provides optimistic UI pattern with rollback on error"
    - "All hook options are type-safe and documented"
    - "Toast notifications fire on mutation success/error"
    - "At least one existing hook migrated to use new patterns as proof-of-concept"
  artifacts:
    - path: "apps/admin/src/hooks/use-base-query.ts"
      provides: "Base query hook factory with automatic realtime subscription"
      exports: ["useBaseQuery", "useBaseList", "useBaseDetail"]
    - path: "apps/admin/src/hooks/use-base-mutation.ts"
      provides: "Base mutation hook factory with optimistic UI"
      exports: ["useBaseMutation", "useOptimisticMutation"]
    - path: "apps/admin/src/hooks/index.ts"
      provides: "Barrel export for hooks"
      exports: ["useBaseQuery", "useBaseMutation"]
  key_links:
    - from: "apps/admin/src/hooks/use-base-query.ts"
      to: "@/lib/queries/config"
      via: "import getCacheConfig"
      pattern: "getCacheConfig\\("
    - from: "apps/admin/src/hooks/use-base-query.ts"
      to: "@/hooks/use-realtime-sync"
      via: "import useRealtimeSync"
      pattern: "useRealtimeSync\\("
    - from: "apps/admin/src/hooks/use-base-mutation.ts"
      to: "@/hooks/use-toast"
      via: "import useToast"
      pattern: "useToast\\(\\)"
---

<objective>
Create base hook templates that establish standardized patterns for React Query usage across the codebase.

Purpose: Provide reusable patterns for queries (with automatic realtime sync) and mutations (with optimistic UI and rollback) that all hooks can follow. This implements SYNC-05 (Base Hook Templates) and SYNC-06 (Optimistic UI with Rollback).

Output: Two new hook files that serve as templates/factories for creating consistent data hooks, plus one existing hook migrated as proof-of-concept.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS-v1.4.md

Reference existing patterns:
@apps/admin/src/lib/queries/config.ts - Cache timing constants
@apps/admin/src/lib/queries/keys.ts - Query key registry
@apps/admin/src/hooks/use-clients.ts - Current hook pattern (to be improved)
@apps/admin/src/hooks/use-realtime-sync.ts - Realtime subscription pattern (TableName type)
@apps/admin/src/hooks/use-toast.ts - Toast notification hook
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create use-base-query.ts with realtime subscription (SYNC-05.1, SYNC-05.3)</name>
  <files>apps/admin/src/hooks/use-base-query.ts</files>
  <action>
Create `src/hooks/use-base-query.ts` with base query patterns INCLUDING automatic realtime subscription:

```typescript
/**
 * Base Query Hook Templates
 *
 * Provides standardized patterns for React Query usage:
 * - Consistent cache timing via getCacheConfig
 * - Type-safe query options
 * - Built-in loading/error state helpers
 * - AUTOMATIC realtime subscription (SYNC-05.3)
 *
 * Usage:
 *   const { data, isLoading, error } = useBaseQuery({
 *     queryKey: clientKeys.list({}),
 *     queryFn: async () => fetchClients(),
 *     cacheStrategy: 'realtime',
 *     realtimeTable: 'clients'  // Enables automatic realtime sync
 *   })
 */

import { useQuery, UseQueryOptions, QueryKey } from '@tanstack/react-query'
import { getCacheConfig, CacheStrategy } from '@/lib/queries/config'
import { useRealtimeSync } from '@/hooks/use-realtime-sync'
import { useMemo } from 'react'

// Import TableName type from realtime-sync (or duplicate if not exported)
type TableName =
  | 'clients'
  | 'properties'
  | 'equipment'
  | 'work_orders'
  | 'inspections'
  | 'invoices'
  | 'service_requests'
  | 'vendors'
  | 'reminders'
  | 'calendar_events'
  | 'programs'
  | 'notifications'
  | 'user_property_assignments'
  | 'recommendations'

interface BaseQueryOptions<TData, TError = Error>
  extends Omit<UseQueryOptions<TData, TError, TData, QueryKey>, 'staleTime'> {
  cacheStrategy?: CacheStrategy
  /** Table name for automatic realtime subscription (SYNC-05.3) */
  realtimeTable?: TableName
}

/**
 * Base query hook with standardized cache timing and optional realtime sync
 *
 * @param options - Query options with cacheStrategy instead of raw staleTime
 * @returns Standard React Query result
 */
export function useBaseQuery<TData, TError = Error>(
  options: BaseQueryOptions<TData, TError>
) {
  const { cacheStrategy = 'standard', realtimeTable, ...queryOptions } = options
  const cacheConfig = getCacheConfig(cacheStrategy)

  // Set up realtime subscription if table specified (SYNC-05.3)
  const tables = useMemo(
    () => (realtimeTable ? [realtimeTable] : []),
    [realtimeTable]
  )
  useRealtimeSync({ tables })

  return useQuery({
    ...queryOptions,
    ...cacheConfig,
  })
}

/**
 * Specialized hook for list queries
 * Uses realtime strategy by default for live updates
 */
export function useBaseList<TData, TError = Error>(
  options: Omit<BaseQueryOptions<TData[], TError>, 'cacheStrategy'> & {
    cacheStrategy?: CacheStrategy
  }
) {
  return useBaseQuery<TData[], TError>({
    ...options,
    cacheStrategy: options.cacheStrategy ?? 'realtime',
  })
}

/**
 * Specialized hook for detail queries
 * Uses realtime strategy by default for live updates
 */
export function useBaseDetail<TData, TError = Error>(
  options: Omit<BaseQueryOptions<TData, TError>, 'cacheStrategy'> & {
    cacheStrategy?: CacheStrategy
    id: string | undefined
  }
) {
  const { id, ...queryOptions } = options

  return useBaseQuery<TData, TError>({
    ...queryOptions,
    cacheStrategy: options.cacheStrategy ?? 'realtime',
    enabled: !!id && (options.enabled ?? true),
  })
}
```

Key requirements:
- Import getCacheConfig from `@/lib/queries/config`
- Import useRealtimeSync from `@/hooks/use-realtime-sync`
- Accept `realtimeTable` option and call useRealtimeSync internally (SYNC-05.3)
- Provide three exported hooks: useBaseQuery, useBaseList, useBaseDetail
- Type-safe with proper generics
- Document with JSDoc comments for pattern documentation (SYNC-05.5)
- useBaseList and useBaseDetail default to 'realtime' cache strategy
  </action>
  <verify>
- File exists at apps/admin/src/hooks/use-base-query.ts
- Contains `useRealtimeSync` import and call
- TypeScript compiles without errors: `cd apps/admin && npx tsc --noEmit`
- Exports useBaseQuery, useBaseList, useBaseDetail
  </verify>
  <done>Base query hook template exists with standardized cache strategy pattern AND automatic realtime subscription</done>
</task>

<task type="auto">
  <name>Task 2: Create use-base-mutation.ts (SYNC-05.2, SYNC-05.4, SYNC-06)</name>
  <files>apps/admin/src/hooks/use-base-mutation.ts</files>
  <action>
Create `src/hooks/use-base-mutation.ts` with optimistic mutation patterns:

```typescript
/**
 * Base Mutation Hook Templates
 *
 * Provides standardized patterns for React Query mutations:
 * - Optimistic UI updates (SYNC-06.1)
 * - Automatic rollback on error (SYNC-06.2)
 * - Always refetch on settled (SYNC-06.3)
 * - Toast notifications on success/error (SYNC-06.5)
 *
 * Usage:
 *   const mutation = useOptimisticMutation({
 *     mutationFn: (data) => updateClient(data),
 *     queryKey: clientKeys.list({}),
 *     updateCache: (old, newData) => [...old, newData],
 *     successMessage: 'Client updated successfully',
 *   })
 */

import { useMutation, useQueryClient, QueryKey, MutationOptions } from '@tanstack/react-query'
import { useToast } from '@/hooks/use-toast'

interface BaseMutationOptions<TData, TError, TVariables, TContext>
  extends Omit<MutationOptions<TData, TError, TVariables, TContext>, 'onSuccess' | 'onError'> {
  successMessage?: string
  errorMessage?: string
  onSuccess?: (data: TData, variables: TVariables, context: TContext | undefined) => void
  onError?: (error: TError, variables: TVariables, context: TContext | undefined) => void
  invalidateKeys?: QueryKey[]
}

/**
 * Base mutation hook with toast notifications
 *
 * @param options - Mutation options with success/error messages
 */
export function useBaseMutation<TData, TError = Error, TVariables = void, TContext = unknown>(
  options: BaseMutationOptions<TData, TError, TVariables, TContext>
) {
  const { toast } = useToast()
  const queryClient = useQueryClient()
  const { successMessage, errorMessage, invalidateKeys, onSuccess, onError, ...mutationOptions } = options

  return useMutation({
    ...mutationOptions,
    onSuccess: (data, variables, context) => {
      // Show success toast
      if (successMessage) {
        toast({
          title: 'Success',
          description: successMessage,
        })
      }

      // Invalidate related queries
      if (invalidateKeys) {
        invalidateKeys.forEach((key) => {
          queryClient.invalidateQueries({ queryKey: key })
        })
      }

      // Call custom onSuccess
      onSuccess?.(data, variables, context)
    },
    onError: (error, variables, context) => {
      // Show error toast
      toast({
        title: 'Error',
        description: errorMessage || (error as Error).message || 'An error occurred',
        variant: 'destructive',
      })

      // Log error for debugging
      console.error('[Mutation Error]', { error, variables })

      // Call custom onError
      onError?.(error, variables, context)
    },
  })
}

interface OptimisticMutationOptions<TData, TError, TVariables, TCacheData>
  extends Omit<BaseMutationOptions<TData, TError, TVariables, { previousData: TCacheData | undefined }>, 'onMutate'> {
  queryKey: QueryKey
  updateCache: (oldData: TCacheData | undefined, variables: TVariables) => TCacheData
}

/**
 * Optimistic mutation hook with automatic rollback
 *
 * Implements the optimistic UI pattern:
 * 1. onMutate: Save current cache and update optimistically (SYNC-06.1)
 * 2. onError: Rollback to previous state (SYNC-06.2)
 * 3. onSettled: Always refetch to ensure consistency (SYNC-06.3)
 *
 * @param options - Mutation options with cache update function
 */
export function useOptimisticMutation<TData, TError = Error, TVariables = void, TCacheData = unknown>(
  options: OptimisticMutationOptions<TData, TError, TVariables, TCacheData>
) {
  const { toast } = useToast()
  const queryClient = useQueryClient()
  const { queryKey, updateCache, successMessage, errorMessage, invalidateKeys, onSuccess, onError, ...mutationOptions } = options

  return useMutation({
    ...mutationOptions,

    // Step 1: Optimistic update (SYNC-06.1)
    onMutate: async (variables: TVariables) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey })

      // Snapshot current value
      const previousData = queryClient.getQueryData<TCacheData>(queryKey)

      // Optimistically update cache
      queryClient.setQueryData<TCacheData>(queryKey, (old) => updateCache(old, variables))

      // Return context with previous value
      return { previousData }
    },

    // Step 2: Rollback on error (SYNC-06.2)
    onError: (error, variables, context) => {
      // Rollback to previous state
      if (context?.previousData !== undefined) {
        queryClient.setQueryData(queryKey, context.previousData)
      }

      // Show error toast
      toast({
        title: 'Error',
        description: errorMessage || (error as Error).message || 'An error occurred',
        variant: 'destructive',
      })

      // Log error
      console.error('[Optimistic Mutation Error]', { error, variables })

      // Call custom onError
      onError?.(error, variables, context)
    },

    // Success handling
    onSuccess: (data, variables, context) => {
      if (successMessage) {
        toast({
          title: 'Success',
          description: successMessage,
        })
      }
      onSuccess?.(data, variables, context)
    },

    // Step 3: Always refetch (SYNC-06.3)
    onSettled: () => {
      // Always refetch to ensure server state consistency
      queryClient.invalidateQueries({ queryKey })

      // Also invalidate any additional keys
      if (invalidateKeys) {
        invalidateKeys.forEach((key) => {
          queryClient.invalidateQueries({ queryKey: key })
        })
      }
    },
  })
}
```

Key requirements:
- Import useToast from `@/hooks/use-toast`
- Implement onMutate for optimistic cache updates (SYNC-06.1)
- Implement onError rollback to previous state (SYNC-06.2)
- Implement onSettled to always refetch (SYNC-06.3)
- Show toast on success/error (SYNC-06.5)
- Log errors to console for debugging
- Type-safe with proper generics
  </action>
  <verify>
- File exists at apps/admin/src/hooks/use-base-mutation.ts
- TypeScript compiles without errors: `cd apps/admin && npx tsc --noEmit`
- Exports useBaseMutation, useOptimisticMutation
  </verify>
  <done>Base mutation hook template exists with optimistic UI and rollback pattern</done>
</task>

<task type="auto">
  <name>Task 3: Create hooks barrel export</name>
  <files>apps/admin/src/hooks/index.ts</files>
  <action>
Create `src/hooks/index.ts` barrel export file:

```typescript
/**
 * Hooks Barrel Export
 *
 * Re-exports base hook templates for convenient imports:
 *   import { useBaseQuery, useOptimisticMutation } from '@/hooks'
 */

// Base hook templates
export { useBaseQuery, useBaseList, useBaseDetail } from './use-base-query'
export { useBaseMutation, useOptimisticMutation } from './use-base-mutation'
```

Note: Only export the base templates. Existing hooks (use-clients, use-properties, etc.) should continue to be imported directly to avoid circular dependencies and keep bundle size optimized.
  </action>
  <verify>
- File exists at apps/admin/src/hooks/index.ts
- TypeScript compiles without errors
- Can import: `import { useBaseQuery, useOptimisticMutation } from '@/hooks'`
  </verify>
  <done>Hooks barrel export provides convenient access to base templates</done>
</task>

<task type="auto">
  <name>Task 4: Migrate useUpdateClient to use useOptimisticMutation (SYNC-06.4 proof-of-concept)</name>
  <files>apps/admin/src/hooks/use-clients.ts</files>
  <action>
Read `src/hooks/use-clients.ts` and update the `useUpdateClient` mutation to use the new `useOptimisticMutation` pattern as a proof-of-concept.

Replace the existing useUpdateClient implementation with:

```typescript
import { useOptimisticMutation } from './use-base-mutation'
import { clientKeys } from '@/lib/queries/keys'

// ... existing code ...

/**
 * Update client mutation with optimistic UI (SYNC-06.4 proof-of-concept)
 */
export function useUpdateClient() {
  return useOptimisticMutation<Client, Error, { id: string; data: Partial<Client> }, Client[]>({
    mutationFn: async ({ id, data }) => {
      const { data: result, error } = await supabase
        .from('clients')
        .update(data)
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return result
    },
    queryKey: clientKeys.list({}),
    updateCache: (oldData, { id, data }) => {
      if (!oldData) return []
      return oldData.map((client) =>
        client.id === id ? { ...client, ...data } : client
      )
    },
    successMessage: 'Client updated successfully',
    errorMessage: 'Failed to update client',
  })
}
```

This demonstrates the pattern for migrating existing mutations. Full migration of all CRUD mutations is deferred to v1.5.

Key changes:
- Import useOptimisticMutation from './use-base-mutation'
- Replace raw useMutation with useOptimisticMutation
- Define updateCache function for optimistic updates
- Add success/error messages for toasts
  </action>
  <verify>
- useUpdateClient uses useOptimisticMutation
- TypeScript compiles without errors: `cd apps/admin && npx tsc --noEmit`
- Comment mentions "proof-of-concept" for SYNC-06.4
  </verify>
  <done>One existing mutation migrated to demonstrate the optimistic UI pattern</done>
</task>

</tasks>

<verification>
Run these commands to verify plan completion:

```bash
# 1. Verify files exist
ls -la apps/admin/src/hooks/use-base-query.ts
ls -la apps/admin/src/hooks/use-base-mutation.ts
ls -la apps/admin/src/hooks/index.ts

# 2. Verify realtime subscription in base query
grep -n "useRealtimeSync" apps/admin/src/hooks/use-base-query.ts

# 3. Verify TypeScript compiles
cd apps/admin && npx tsc --noEmit

# 4. Check exports
grep -E "export (function|const)" apps/admin/src/hooks/use-base-query.ts
grep -E "export (function|const)" apps/admin/src/hooks/use-base-mutation.ts

# 5. Verify migration proof-of-concept
grep -n "useOptimisticMutation" apps/admin/src/hooks/use-clients.ts

# 6. Verify production build
cd apps/admin && npm run build
```
</verification>

<success_criteria>
- [ ] use-base-query.ts exists with useBaseQuery, useBaseList, useBaseDetail exports
- [ ] use-base-query.ts includes automatic realtime subscription via realtimeTable option (SYNC-05.3)
- [ ] use-base-mutation.ts exists with useBaseMutation, useOptimisticMutation exports
- [ ] Optimistic mutation implements onMutate, onError (rollback), onSettled (refetch)
- [ ] Toast notifications fire on success/error
- [ ] useUpdateClient migrated to useOptimisticMutation as proof-of-concept (SYNC-06.4)
- [ ] TypeScript compiles without errors
- [ ] Production build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/v1.4-04-pattern-templates/04-01-SUMMARY.md`
</output>
