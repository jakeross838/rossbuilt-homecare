# Plan 11-03: Service Request & Recommendation Hooks

## Objective

Create React Query hooks for client portal mutations: service requests and recommendation responses. These hooks enable clients to submit service requests and respond to recommendations (approve/decline).

## Dependencies

- 11-01: Portal types, constants, and validation schemas
- 11-02: Portal query key factory (`portalKeys`)
- Existing mutation patterns from `use-work-orders.ts`, `use-invoices.ts`

## Constraints

- Clients can only create service requests for their own properties
- Clients can only respond to pending recommendations for their properties
- RLS policies automatically enforce client_id filtering
- Must handle photo uploads for service requests

## Tasks

### Task 1: Service Request Hooks

Create `apps/admin/src/hooks/use-service-requests.ts`:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import { portalKeys } from './use-portal-dashboard'
import type {
  PortalServiceRequest,
  PortalServiceRequestComment,
} from '@/lib/types/portal'
import type { CreateServiceRequestInput, AddServiceRequestCommentInput } from '@/lib/validations/service-request'

// Service request query keys
export const serviceRequestKeys = {
  all: ['service-requests'] as const,
  lists: () => [...serviceRequestKeys.all, 'list'] as const,
  list: (filters: { status?: string; propertyId?: string }) =>
    [...serviceRequestKeys.lists(), filters] as const,
  details: () => [...serviceRequestKeys.all, 'detail'] as const,
  detail: (id: string) => [...serviceRequestKeys.details(), id] as const,
  comments: (requestId: string) =>
    [...serviceRequestKeys.detail(requestId), 'comments'] as const,
}

interface UseServiceRequestsOptions {
  status?: string
  propertyId?: string
}

/**
 * Hook to fetch service requests for client portal
 */
export function useServiceRequests(options: UseServiceRequestsOptions = {}) {
  const { status, propertyId } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: serviceRequestKeys.list({ status, propertyId }),
    queryFn: async (): Promise<PortalServiceRequest[]> => {
      let query = supabase
        .from('service_requests')
        .select(`
          id,
          request_number,
          request_type,
          title,
          description,
          priority,
          status,
          photos,
          resolution,
          resolved_at,
          acknowledged_at,
          work_order_id,
          created_at,
          updated_at,
          property:properties (
            id,
            name,
            address_line1
          )
        `)
        .order('created_at', { ascending: false })

      if (status) {
        query = query.eq('status', status)
      }

      if (propertyId) {
        query = query.eq('property_id', propertyId)
      }

      const { data, error } = await query

      if (error) throw error

      return (data || []).map((sr) => ({
        id: sr.id,
        request_number: sr.request_number,
        request_type: sr.request_type,
        title: sr.title,
        description: sr.description,
        priority: sr.priority,
        status: sr.status,
        photos: sr.photos || [],
        property: sr.property as { id: string; name: string; address_line1: string },
        resolution: sr.resolution,
        resolved_at: sr.resolved_at,
        acknowledged_at: sr.acknowledged_at,
        work_order_id: sr.work_order_id,
        created_at: sr.created_at,
        updated_at: sr.updated_at,
      }))
    },
    enabled: profile?.role === 'client',
  })
}

/**
 * Hook to fetch single service request with comments
 */
export function useServiceRequest(requestId: string | undefined) {
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: serviceRequestKeys.detail(requestId || ''),
    queryFn: async (): Promise<PortalServiceRequest & { comments: PortalServiceRequestComment[] }> => {
      if (!requestId) throw new Error('Request ID required')

      const { data, error } = await supabase
        .from('service_requests')
        .select(`
          id,
          request_number,
          request_type,
          title,
          description,
          priority,
          status,
          photos,
          resolution,
          resolved_at,
          acknowledged_at,
          work_order_id,
          created_at,
          updated_at,
          property:properties (
            id,
            name,
            address_line1
          )
        `)
        .eq('id', requestId)
        .single()

      if (error) throw error

      // Fetch comments (RLS filters to non-internal for clients)
      const { data: comments } = await supabase
        .from('service_request_comments')
        .select(`
          id,
          comment,
          created_at,
          user:users (
            first_name,
            last_name,
            role
          )
        `)
        .eq('service_request_id', requestId)
        .order('created_at', { ascending: true })

      return {
        id: data.id,
        request_number: data.request_number,
        request_type: data.request_type,
        title: data.title,
        description: data.description,
        priority: data.priority,
        status: data.status,
        photos: data.photos || [],
        property: data.property as { id: string; name: string; address_line1: string },
        resolution: data.resolution,
        resolved_at: data.resolved_at,
        acknowledged_at: data.acknowledged_at,
        work_order_id: data.work_order_id,
        created_at: data.created_at,
        updated_at: data.updated_at,
        comments: (comments || []).map((c) => ({
          id: c.id,
          comment: c.comment,
          created_at: c.created_at,
          user: c.user as { first_name: string; last_name: string; role: string } | null,
        })),
      }
    },
    enabled: !!requestId && profile?.role === 'client',
  })
}

/**
 * Hook to create a new service request
 */
export function useCreateServiceRequest() {
  const queryClient = useQueryClient()
  const profile = useAuthStore((state) => state.profile)

  return useMutation({
    mutationFn: async (input: CreateServiceRequestInput) => {
      // Get client_id from current user's linked client
      const { data: client } = await supabase
        .from('clients')
        .select('id')
        .eq('user_id', profile?.id)
        .single()

      if (!client) throw new Error('Client not found')

      // Get organization_id from property
      const { data: property } = await supabase
        .from('properties')
        .select('organization_id')
        .eq('id', input.property_id)
        .single()

      if (!property) throw new Error('Property not found')

      // Generate request number
      const { data: seqData } = await supabase.rpc('nextval', {
        seq_name: 'service_request_seq',
      })

      const requestNumber = seqData
        ? `SR-${String(seqData).padStart(4, '0')}`
        : `SR-${Date.now()}`

      const { data, error } = await supabase
        .from('service_requests')
        .insert({
          organization_id: property.organization_id,
          property_id: input.property_id,
          client_id: client.id,
          request_number: requestNumber,
          request_type: input.request_type,
          title: input.title,
          description: input.description,
          priority: input.priority,
          photos: input.photos || [],
          status: 'new',
        })
        .select()
        .single()

      if (error) throw error

      return data
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: serviceRequestKeys.lists() })
      queryClient.invalidateQueries({ queryKey: portalKeys.dashboard() })
    },
  })
}

/**
 * Hook to add a comment to a service request
 */
export function useAddServiceRequestComment() {
  const queryClient = useQueryClient()
  const user = useAuthStore((state) => state.user)

  return useMutation({
    mutationFn: async (input: AddServiceRequestCommentInput) => {
      const { data, error } = await supabase
        .from('service_request_comments')
        .insert({
          service_request_id: input.service_request_id,
          user_id: user?.id,
          comment: input.comment,
          is_internal: false, // Clients can only post non-internal comments
        })
        .select()
        .single()

      if (error) throw error

      return data
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: serviceRequestKeys.detail(variables.service_request_id),
      })
    },
  })
}

/**
 * Hook to upload photos for service request
 */
export function useUploadServiceRequestPhoto() {
  return useMutation({
    mutationFn: async ({
      file,
      requestId,
    }: {
      file: File
      requestId?: string
    }): Promise<string> => {
      const fileExt = file.name.split('.').pop()
      const fileName = `${requestId || 'temp'}-${Date.now()}.${fileExt}`
      const filePath = `service-requests/${fileName}`

      const { error: uploadError } = await supabase.storage
        .from('service-request-photos')
        .upload(filePath, file)

      if (uploadError) throw uploadError

      const { data: urlData } = supabase.storage
        .from('service-request-photos')
        .getPublicUrl(filePath)

      return urlData.publicUrl
    },
  })
}
```

### Task 2: Recommendation Response Hook

Create `apps/admin/src/hooks/use-recommendation-response.ts`:

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import { portalKeys } from './use-portal-dashboard'
import type { RecommendationResponseInput } from '@/lib/validations/service-request'

/**
 * Hook for client to respond to a recommendation (approve/decline)
 */
export function useRespondToRecommendation() {
  const queryClient = useQueryClient()
  const user = useAuthStore((state) => state.user)

  return useMutation({
    mutationFn: async (input: RecommendationResponseInput) => {
      const { data, error } = await supabase
        .from('recommendations')
        .update({
          status: input.status,
          client_response_notes: input.notes || null,
          responded_at: new Date().toISOString(),
          responded_by: user?.id,
          updated_at: new Date().toISOString(),
        })
        .eq('id', input.recommendation_id)
        .eq('status', 'pending') // Can only respond to pending recommendations
        .select()
        .single()

      if (error) throw error

      return data
    },
    onSuccess: () => {
      // Invalidate all portal queries that might show recommendations
      queryClient.invalidateQueries({ queryKey: portalKeys.dashboard() })
      queryClient.invalidateQueries({ queryKey: portalKeys.properties() })
    },
  })
}

/**
 * Hook to approve a recommendation (convenience wrapper)
 */
export function useApproveRecommendation() {
  const respondMutation = useRespondToRecommendation()

  return {
    ...respondMutation,
    mutate: (recommendationId: string, notes?: string) =>
      respondMutation.mutate({
        recommendation_id: recommendationId,
        status: 'approved',
        notes,
      }),
    mutateAsync: (recommendationId: string, notes?: string) =>
      respondMutation.mutateAsync({
        recommendation_id: recommendationId,
        status: 'approved',
        notes,
      }),
  }
}

/**
 * Hook to decline a recommendation (convenience wrapper)
 */
export function useDeclineRecommendation() {
  const respondMutation = useRespondToRecommendation()

  return {
    ...respondMutation,
    mutate: (recommendationId: string, notes?: string) =>
      respondMutation.mutate({
        recommendation_id: recommendationId,
        status: 'declined',
        notes,
      }),
    mutateAsync: (recommendationId: string, notes?: string) =>
      respondMutation.mutateAsync({
        recommendation_id: recommendationId,
        status: 'declined',
        notes,
      }),
  }
}
```

### Task 3: Add Database Migration for Client Response Fields

Create `apps/admin/src/lib/migrations/021_recommendation_response.sql`:

```sql
-- 021_recommendation_response.sql
-- Add client response fields to recommendations table

ALTER TABLE recommendations
ADD COLUMN IF NOT EXISTS client_response_notes TEXT,
ADD COLUMN IF NOT EXISTS responded_at TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS responded_by UUID REFERENCES users(id);

-- Index for finding responded recommendations
CREATE INDEX IF NOT EXISTS idx_recommendations_responded
  ON recommendations(responded_at) WHERE responded_at IS NOT NULL;
```

Note: This migration should be applied to Supabase. Create the file for reference.

### Task 4: Storage Bucket Setup Note

Create `apps/admin/src/lib/storage/SERVICE_REQUEST_STORAGE.md`:

```markdown
# Service Request Photo Storage Setup

## Required Supabase Storage Configuration

1. Create a new storage bucket in Supabase Dashboard:
   - Name: `service-request-photos`
   - Public: Yes (for viewing photos in portal)
   - File size limit: 10MB
   - Allowed MIME types: `image/jpeg`, `image/png`, `image/webp`

2. Add RLS policies:

```sql
-- Anyone authenticated can upload
CREATE POLICY "Authenticated users can upload service request photos"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'service-request-photos');

-- Anyone can read (public bucket)
CREATE POLICY "Public read access for service request photos"
ON storage.objects FOR SELECT
TO public
USING (bucket_id = 'service-request-photos');

-- Clients can delete their own uploads (optional)
CREATE POLICY "Users can delete their own uploads"
ON storage.objects FOR DELETE
TO authenticated
USING (bucket_id = 'service-request-photos' AND auth.uid()::text = (storage.foldername(name))[1]);
```

3. The bucket will store photos at:
   `service-requests/{request-id}-{timestamp}.{ext}`
```

## Verification

After completing all tasks, verify:

1. **Types compile**: `cd apps/admin && npx tsc --noEmit`
2. **Files exist**:
   - `apps/admin/src/hooks/use-service-requests.ts`
   - `apps/admin/src/hooks/use-recommendation-response.ts`
   - `apps/admin/src/lib/migrations/021_recommendation_response.sql`
   - `apps/admin/src/lib/storage/SERVICE_REQUEST_STORAGE.md`
3. **Hooks export correctly**: All hooks can be imported

## Commit

```
feat(portal): add service request and recommendation hooks

- Add service request CRUD hooks for client portal
- Add recommendation response hooks (approve/decline)
- Add photo upload hook for service requests
- Add migration for recommendation response fields
- Document storage bucket setup for photos
```
