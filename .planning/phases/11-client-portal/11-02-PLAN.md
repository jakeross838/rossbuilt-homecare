# Plan 11-02: Client Portal Hooks

## Objective

Create React Query hooks for client portal data fetching. These hooks are designed for the client role and leverage existing RLS policies that filter data by `client_id = get_user_client_id()`.

## Dependencies

- 11-01: Portal types and constants
- Existing hooks pattern from `use-clients.ts`, `use-properties.ts`
- Auth store with user profile containing role

## Constraints

- Must use existing Supabase client
- RLS policies handle data filtering automatically for client role users
- Read-only operations only (clients don't modify core data, only respond to recommendations and submit service requests)

## Tasks

### Task 1: Portal Auth Hook

Create `apps/admin/src/hooks/use-portal-auth.ts`:

```typescript
import { useAuthStore } from '@/stores/auth-store'

/**
 * Hook to check if current user is a client
 * and get client-specific auth info
 */
export function usePortalAuth() {
  const { user, profile, isLoading, isInitialized } = useAuthStore()

  const isClient = profile?.role === 'client'
  const isAuthenticated = !!user && !!profile

  return {
    user,
    profile,
    isClient,
    isAuthenticated,
    isLoading,
    isInitialized,
  }
}
```

### Task 2: Client Portal Dashboard Hook

Create `apps/admin/src/hooks/use-portal-dashboard.ts`:

```typescript
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import type { PortalDashboardSummary, PortalProperty } from '@/lib/types/portal'

// Query keys for portal
export const portalKeys = {
  all: ['portal'] as const,
  dashboard: () => [...portalKeys.all, 'dashboard'] as const,
  properties: () => [...portalKeys.all, 'properties'] as const,
  property: (id: string) => [...portalKeys.properties(), id] as const,
  inspections: (filters?: { propertyId?: string }) =>
    [...portalKeys.all, 'inspections', filters] as const,
  inspection: (id: string) => [...portalKeys.all, 'inspection', id] as const,
  requests: (filters?: { status?: string }) =>
    [...portalKeys.all, 'requests', filters] as const,
  request: (id: string) => [...portalKeys.all, 'request', id] as const,
  invoices: () => [...portalKeys.all, 'invoices'] as const,
  invoice: (id: string) => [...portalKeys.all, 'invoice', id] as const,
}

/**
 * Hook to fetch client portal dashboard summary
 */
export function usePortalDashboard() {
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: portalKeys.dashboard(),
    queryFn: async (): Promise<PortalDashboardSummary> => {
      // Get properties count
      const { count: propertiesCount } = await supabase
        .from('properties')
        .select('*', { count: 'exact', head: true })
        .eq('is_active', true)

      // Get upcoming inspections (next 30 days)
      const thirtyDaysFromNow = new Date()
      thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30)

      const { count: upcomingInspections } = await supabase
        .from('inspections')
        .select('*', { count: 'exact', head: true })
        .eq('status', 'scheduled')
        .gte('scheduled_date', new Date().toISOString())
        .lte('scheduled_date', thirtyDaysFromNow.toISOString())

      // Get open service requests
      const { count: openRequests } = await supabase
        .from('service_requests')
        .select('*', { count: 'exact', head: true })
        .in('status', ['new', 'acknowledged', 'in_progress', 'scheduled'])

      // Get pending recommendations
      const { count: pendingApprovals } = await supabase
        .from('recommendations')
        .select('*', { count: 'exact', head: true })
        .eq('status', 'pending')

      // Get outstanding balance from invoices
      const { data: invoices } = await supabase
        .from('invoices')
        .select('balance_due')
        .in('status', ['sent', 'viewed', 'partial', 'overdue'])

      const outstandingBalance = invoices?.reduce(
        (sum, inv) => sum + (inv.balance_due || 0),
        0
      ) || 0

      return {
        properties_count: propertiesCount || 0,
        upcoming_inspections: upcomingInspections || 0,
        open_service_requests: openRequests || 0,
        pending_approvals: pendingApprovals || 0,
        outstanding_balance: outstandingBalance,
      }
    },
    enabled: profile?.role === 'client',
    staleTime: 1000 * 60 * 5, // 5 minutes
  })
}

/**
 * Hook to fetch client's properties for portal
 */
export function usePortalProperties() {
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: portalKeys.properties(),
    queryFn: async (): Promise<PortalProperty[]> => {
      // Fetch properties with related counts
      const { data: properties, error } = await supabase
        .from('properties')
        .select(`
          id,
          name,
          address_line1,
          city,
          state,
          zip,
          primary_photo_url,
          programs!inner (
            id,
            tier,
            frequency,
            status,
            monthly_price,
            next_inspection_date
          )
        `)
        .eq('is_active', true)
        .order('name')

      if (error) throw error

      // For each property, get counts
      const propertiesWithCounts = await Promise.all(
        (properties || []).map(async (prop) => {
          // Equipment count
          const { count: equipmentCount } = await supabase
            .from('equipment')
            .select('*', { count: 'exact', head: true })
            .eq('property_id', prop.id)
            .eq('is_active', true)

          // Open work orders
          const { count: openWorkOrders } = await supabase
            .from('work_orders')
            .select('*', { count: 'exact', head: true })
            .eq('property_id', prop.id)
            .in('status', ['pending', 'vendor_assigned', 'scheduled', 'in_progress'])

          // Pending recommendations
          const { count: pendingRecs } = await supabase
            .from('recommendations')
            .select('*', { count: 'exact', head: true })
            .eq('property_id', prop.id)
            .eq('status', 'pending')

          // Last inspection
          const { data: lastInspection } = await supabase
            .from('inspections')
            .select('scheduled_date, overall_condition')
            .eq('property_id', prop.id)
            .eq('status', 'completed')
            .order('scheduled_date', { ascending: false })
            .limit(1)
            .single()

          const program = Array.isArray(prop.programs) ? prop.programs[0] : prop.programs

          return {
            id: prop.id,
            name: prop.name,
            address_line1: prop.address_line1,
            city: prop.city,
            state: prop.state,
            zip: prop.zip,
            primary_photo_url: prop.primary_photo_url,
            program: program ? {
              id: program.id,
              tier: program.tier,
              frequency: program.frequency,
              status: program.status,
              monthly_price: program.monthly_price,
              next_inspection_date: program.next_inspection_date,
            } : null,
            equipment_count: equipmentCount || 0,
            open_work_order_count: openWorkOrders || 0,
            pending_recommendation_count: pendingRecs || 0,
            last_inspection_date: lastInspection?.scheduled_date || null,
            overall_condition: lastInspection?.overall_condition || null,
          } satisfies PortalProperty
        })
      )

      return propertiesWithCounts
    },
    enabled: profile?.role === 'client',
  })
}
```

### Task 3: Portal Property Detail Hook

Create `apps/admin/src/hooks/use-portal-property.ts`:

```typescript
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import { portalKeys } from './use-portal-dashboard'
import type {
  PortalPropertyDetail,
  PortalEquipment,
  PortalInspection,
  PortalWorkOrder,
  PortalRecommendation,
} from '@/lib/types/portal'

/**
 * Hook to fetch detailed property info for client portal
 */
export function usePortalProperty(propertyId: string | undefined) {
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: portalKeys.property(propertyId || ''),
    queryFn: async (): Promise<PortalPropertyDetail> => {
      if (!propertyId) throw new Error('Property ID required')

      // Fetch property with program
      const { data: property, error } = await supabase
        .from('properties')
        .select(`
          id,
          name,
          address_line1,
          address_line2,
          city,
          state,
          zip,
          primary_photo_url,
          property_type,
          square_footage,
          year_built,
          gate_code,
          alarm_code,
          programs (
            id,
            tier,
            frequency,
            status,
            monthly_price,
            next_inspection_date
          )
        `)
        .eq('id', propertyId)
        .single()

      if (error) throw error

      // Fetch equipment
      const { data: equipmentData } = await supabase
        .from('equipment')
        .select(`
          id,
          name,
          category,
          location,
          condition,
          last_serviced_at,
          next_service_date
        `)
        .eq('property_id', propertyId)
        .eq('is_active', true)
        .order('category')

      const equipment: PortalEquipment[] = (equipmentData || []).map((e) => ({
        id: e.id,
        name: e.name,
        category: e.category,
        location: e.location,
        condition: e.condition,
        last_serviced_at: e.last_serviced_at,
        next_service_date: e.next_service_date,
      }))

      // Fetch recent inspections (last 5)
      const { data: inspectionsData } = await supabase
        .from('inspections')
        .select(`
          id,
          scheduled_date,
          inspection_type,
          status,
          overall_condition,
          summary,
          report_url,
          inspector:users!inspections_inspector_id_fkey (
            first_name,
            last_name
          ),
          findings
        `)
        .eq('property_id', propertyId)
        .in('status', ['completed', 'scheduled', 'in_progress'])
        .order('scheduled_date', { ascending: false })
        .limit(5)

      const recentInspections: PortalInspection[] = (inspectionsData || []).map((i) => {
        // Parse findings from JSONB to get summary
        const findings = i.findings as unknown as Array<{ status: string }> | null
        const findingsSummary = {
          total: findings?.length || 0,
          passed: findings?.filter((f) => f.status === 'pass').length || 0,
          needs_attention: findings?.filter((f) => f.status === 'needs_attention').length || 0,
          urgent: findings?.filter((f) => f.status === 'urgent').length || 0,
        }

        return {
          id: i.id,
          inspection_date: i.scheduled_date,
          inspection_type: i.inspection_type,
          status: i.status,
          overall_condition: i.overall_condition,
          summary: i.summary,
          report_url: i.report_url,
          inspector: i.inspector as { first_name: string; last_name: string } | null,
          findings_summary: findingsSummary,
        }
      })

      // Fetch active work orders
      const { data: workOrdersData } = await supabase
        .from('work_orders')
        .select(`
          id,
          work_order_number,
          title,
          description,
          category,
          priority,
          status,
          estimated_cost,
          client_cost,
          scheduled_date,
          completed_at,
          created_at
        `)
        .eq('property_id', propertyId)
        .in('status', ['pending', 'vendor_assigned', 'scheduled', 'in_progress'])
        .order('created_at', { ascending: false })

      const activeWorkOrders: PortalWorkOrder[] = (workOrdersData || []).map((wo) => ({
        id: wo.id,
        work_order_number: wo.work_order_number,
        title: wo.title,
        description: wo.description,
        category: wo.category,
        priority: wo.priority,
        status: wo.status,
        estimated_cost: wo.estimated_cost,
        client_cost: wo.client_cost,
        scheduled_date: wo.scheduled_date,
        completed_at: wo.completed_at,
        created_at: wo.created_at,
      }))

      // Fetch pending recommendations
      const { data: recommendationsData } = await supabase
        .from('recommendations')
        .select(`
          id,
          title,
          description,
          priority,
          status,
          estimated_cost,
          category,
          created_at,
          inspection:inspections (
            id,
            scheduled_date
          )
        `)
        .eq('property_id', propertyId)
        .eq('status', 'pending')
        .order('priority', { ascending: true })

      const pendingRecommendations: PortalRecommendation[] = (recommendationsData || []).map((r) => ({
        id: r.id,
        title: r.title,
        description: r.description,
        priority: r.priority,
        status: r.status,
        estimated_cost: r.estimated_cost,
        category: r.category,
        created_at: r.created_at,
        inspection: r.inspection as { id: string; scheduled_date: string } | null,
      }))

      // Get counts for summary
      const { count: equipmentCount } = await supabase
        .from('equipment')
        .select('*', { count: 'exact', head: true })
        .eq('property_id', propertyId)
        .eq('is_active', true)

      const { count: openWorkOrders } = await supabase
        .from('work_orders')
        .select('*', { count: 'exact', head: true })
        .eq('property_id', propertyId)
        .in('status', ['pending', 'vendor_assigned', 'scheduled', 'in_progress'])

      const { count: pendingRecs } = await supabase
        .from('recommendations')
        .select('*', { count: 'exact', head: true })
        .eq('property_id', propertyId)
        .eq('status', 'pending')

      const program = Array.isArray(property.programs) ? property.programs[0] : property.programs

      return {
        id: property.id,
        name: property.name,
        address_line1: property.address_line1,
        address_line2: property.address_line2,
        city: property.city,
        state: property.state,
        zip: property.zip,
        primary_photo_url: property.primary_photo_url,
        property_type: property.property_type,
        square_footage: property.square_footage,
        year_built: property.year_built,
        gate_code: property.gate_code,
        alarm_code: property.alarm_code,
        program: program ? {
          id: program.id,
          tier: program.tier,
          frequency: program.frequency,
          status: program.status,
          monthly_price: program.monthly_price,
          next_inspection_date: program.next_inspection_date,
        } : null,
        equipment_count: equipmentCount || 0,
        open_work_order_count: openWorkOrders || 0,
        pending_recommendation_count: pendingRecs || 0,
        last_inspection_date: recentInspections[0]?.inspection_date || null,
        overall_condition: recentInspections[0]?.overall_condition || null,
        equipment,
        recent_inspections: recentInspections,
        active_work_orders: activeWorkOrders,
        pending_recommendations: pendingRecommendations,
      }
    },
    enabled: !!propertyId && profile?.role === 'client',
  })
}
```

### Task 4: Portal Inspections Hook

Create `apps/admin/src/hooks/use-portal-inspections.ts`:

```typescript
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import { portalKeys } from './use-portal-dashboard'
import type { PortalInspection } from '@/lib/types/portal'

interface UsePortalInspectionsOptions {
  propertyId?: string
  limit?: number
}

/**
 * Hook to fetch inspections for client portal
 */
export function usePortalInspections(options: UsePortalInspectionsOptions = {}) {
  const { propertyId, limit = 20 } = options
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: portalKeys.inspections({ propertyId }),
    queryFn: async (): Promise<PortalInspection[]> => {
      let query = supabase
        .from('inspections')
        .select(`
          id,
          scheduled_date,
          inspection_type,
          status,
          overall_condition,
          summary,
          report_url,
          inspector:users!inspections_inspector_id_fkey (
            first_name,
            last_name
          ),
          findings,
          property:properties (
            id,
            name
          )
        `)
        .in('status', ['completed', 'scheduled', 'in_progress'])
        .order('scheduled_date', { ascending: false })
        .limit(limit)

      if (propertyId) {
        query = query.eq('property_id', propertyId)
      }

      const { data, error } = await query

      if (error) throw error

      return (data || []).map((i) => {
        const findings = i.findings as unknown as Array<{ status: string }> | null

        return {
          id: i.id,
          inspection_date: i.scheduled_date,
          inspection_type: i.inspection_type,
          status: i.status,
          overall_condition: i.overall_condition,
          summary: i.summary,
          report_url: i.report_url,
          inspector: i.inspector as { first_name: string; last_name: string } | null,
          findings_summary: {
            total: findings?.length || 0,
            passed: findings?.filter((f) => f.status === 'pass').length || 0,
            needs_attention: findings?.filter((f) => f.status === 'needs_attention').length || 0,
            urgent: findings?.filter((f) => f.status === 'urgent').length || 0,
          },
        }
      })
    },
    enabled: profile?.role === 'client',
  })
}

/**
 * Hook to fetch single inspection detail for portal
 */
export function usePortalInspection(inspectionId: string | undefined) {
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: portalKeys.inspection(inspectionId || ''),
    queryFn: async () => {
      if (!inspectionId) throw new Error('Inspection ID required')

      const { data, error } = await supabase
        .from('inspections')
        .select(`
          id,
          scheduled_date,
          inspection_type,
          status,
          overall_condition,
          summary,
          report_url,
          started_at,
          completed_at,
          inspector:users!inspections_inspector_id_fkey (
            first_name,
            last_name
          ),
          findings,
          weather_conditions,
          property:properties (
            id,
            name,
            address_line1,
            city,
            state
          )
        `)
        .eq('id', inspectionId)
        .single()

      if (error) throw error

      // Also fetch inspection photos
      const { data: photos } = await supabase
        .from('inspection_photos')
        .select('id, url, caption, section, taken_at')
        .eq('inspection_id', inspectionId)
        .order('taken_at')

      return {
        ...data,
        photos: photos || [],
      }
    },
    enabled: !!inspectionId && profile?.role === 'client',
  })
}
```

### Task 5: Portal Invoices Hook

Create `apps/admin/src/hooks/use-portal-invoices.ts`:

```typescript
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import { portalKeys } from './use-portal-dashboard'
import type { PortalInvoice } from '@/lib/types/portal'

/**
 * Hook to fetch invoices for client portal
 */
export function usePortalInvoices() {
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: portalKeys.invoices(),
    queryFn: async (): Promise<PortalInvoice[]> => {
      const { data, error } = await supabase
        .from('invoices')
        .select(`
          id,
          invoice_number,
          status,
          issue_date,
          due_date,
          total,
          balance_due,
          stripe_payment_url,
          line_items:invoice_line_items (
            description,
            quantity,
            unit_price,
            amount
          )
        `)
        .order('issue_date', { ascending: false })

      if (error) throw error

      return (data || []).map((inv) => ({
        id: inv.id,
        invoice_number: inv.invoice_number,
        status: inv.status,
        issue_date: inv.issue_date,
        due_date: inv.due_date,
        total: inv.total,
        balance_due: inv.balance_due,
        line_items: (inv.line_items || []).map((li: unknown) => {
          const item = li as {
            description: string
            quantity: number
            unit_price: number
            amount: number
          }
          return {
            description: item.description,
            quantity: item.quantity,
            unit_price: item.unit_price,
            amount: item.amount,
          }
        }),
        stripe_payment_url: inv.stripe_payment_url,
      }))
    },
    enabled: profile?.role === 'client',
  })
}

/**
 * Hook to fetch single invoice for portal
 */
export function usePortalInvoice(invoiceId: string | undefined) {
  const profile = useAuthStore((state) => state.profile)

  return useQuery({
    queryKey: portalKeys.invoice(invoiceId || ''),
    queryFn: async (): Promise<PortalInvoice> => {
      if (!invoiceId) throw new Error('Invoice ID required')

      const { data, error } = await supabase
        .from('invoices')
        .select(`
          id,
          invoice_number,
          status,
          issue_date,
          due_date,
          total,
          balance_due,
          stripe_payment_url,
          notes,
          terms,
          line_items:invoice_line_items (
            description,
            quantity,
            unit_price,
            amount
          )
        `)
        .eq('id', invoiceId)
        .single()

      if (error) throw error

      return {
        id: data.id,
        invoice_number: data.invoice_number,
        status: data.status,
        issue_date: data.issue_date,
        due_date: data.due_date,
        total: data.total,
        balance_due: data.balance_due,
        line_items: (data.line_items || []).map((li: unknown) => {
          const item = li as {
            description: string
            quantity: number
            unit_price: number
            amount: number
          }
          return {
            description: item.description,
            quantity: item.quantity,
            unit_price: item.unit_price,
            amount: item.amount,
          }
        }),
        stripe_payment_url: data.stripe_payment_url,
      }
    },
    enabled: !!invoiceId && profile?.role === 'client',
  })
}
```

## Verification

After completing all tasks, verify:

1. **Types compile**: `cd apps/admin && npx tsc --noEmit`
2. **Files exist**:
   - `apps/admin/src/hooks/use-portal-auth.ts`
   - `apps/admin/src/hooks/use-portal-dashboard.ts`
   - `apps/admin/src/hooks/use-portal-property.ts`
   - `apps/admin/src/hooks/use-portal-inspections.ts`
   - `apps/admin/src/hooks/use-portal-invoices.ts`
3. **Imports work**: All portal types and constants import correctly

## Commit

```
feat(portal): add client portal data hooks

- Add portal auth hook for client role checking
- Add dashboard summary hook with property/inspection counts
- Add property list and detail hooks for portal views
- Add inspections hook with findings summary
- Add invoices hook for billing display
```
