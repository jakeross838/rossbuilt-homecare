---
phase: 06-smart-scheduling
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/admin/src/hooks/use-inspectors.ts
autonomous: true
must_haves:
  truths:
    - "Can fetch list of users with inspector role"
    - "Can see inspector workload for a date range"
  artifacts:
    - path: "apps/admin/src/hooks/use-inspectors.ts"
      provides: "React Query hooks for inspector data and availability"
  key_links:
    - from: "use-inspectors.ts"
      to: "supabase users table"
      via: "query with role filter"
---

<objective>
Create React Query hooks for fetching inspectors and their workload/availability.

Purpose: Enable inspector assignment UI with availability visibility.
Output: Hooks for listing inspectors and calculating their workload.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Database schema
@supabase/migrations/002_organizations_users.sql
@supabase/migrations/008_inspections.sql

# Existing hook patterns
@apps/admin/src/hooks/use-clients.ts
@apps/admin/src/hooks/use-properties.ts
@apps/admin/src/hooks/use-equipment.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create inspector hooks</name>
  <files>apps/admin/src/hooks/use-inspectors.ts</files>
  <action>
Create React Query hooks following existing patterns:

```ts
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import type { Tables } from '@/types/database.types'

type User = Tables<'users'>

// Fetch all users with inspector role
export function useInspectors() {
  return useQuery({
    queryKey: ['inspectors'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('users')
        .select('id, email, full_name, phone, role, is_active')
        .eq('role', 'inspector')
        .eq('is_active', true)
        .order('full_name')

      if (error) throw error
      return data as User[]
    },
  })
}

// Fetch inspector workload for a date range
// Returns count of inspections per inspector per day
export function useInspectorWorkload(startDate: string, endDate: string) {
  return useQuery({
    queryKey: ['inspector-workload', startDate, endDate],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('inspections')
        .select(`
          inspector_id,
          scheduled_date,
          estimated_duration_minutes,
          users!inspections_inspector_id_fkey (
            id,
            full_name
          )
        `)
        .gte('scheduled_date', startDate)
        .lte('scheduled_date', endDate)
        .not('inspector_id', 'is', null)
        .in('status', ['scheduled', 'in_progress'])

      if (error) throw error

      // Aggregate by inspector and date
      const workloadMap = new Map<string, {
        inspector_id: string
        inspector_name: string
        date: string
        inspection_count: number
        total_duration_minutes: number
      }>()

      for (const inspection of data || []) {
        const key = `${inspection.inspector_id}-${inspection.scheduled_date}`
        const existing = workloadMap.get(key)
        const inspectorName = (inspection.users as any)?.full_name || 'Unknown'

        if (existing) {
          existing.inspection_count++
          existing.total_duration_minutes += inspection.estimated_duration_minutes || 60
        } else {
          workloadMap.set(key, {
            inspector_id: inspection.inspector_id!,
            inspector_name: inspectorName,
            date: inspection.scheduled_date,
            inspection_count: 1,
            total_duration_minutes: inspection.estimated_duration_minutes || 60,
          })
        }
      }

      return Array.from(workloadMap.values())
    },
    enabled: !!startDate && !!endDate,
  })
}

// Get inspections for a specific inspector on a specific date
export function useInspectorSchedule(inspectorId: string | null, date: string) {
  return useQuery({
    queryKey: ['inspector-schedule', inspectorId, date],
    queryFn: async () => {
      if (!inspectorId) return []

      const { data, error } = await supabase
        .from('inspections')
        .select(`
          id,
          scheduled_date,
          scheduled_time_start,
          scheduled_time_end,
          estimated_duration_minutes,
          status,
          properties (
            id,
            name,
            address_line1,
            city
          )
        `)
        .eq('inspector_id', inspectorId)
        .eq('scheduled_date', date)
        .in('status', ['scheduled', 'in_progress'])
        .order('scheduled_time_start')

      if (error) throw error
      return data
    },
    enabled: !!inspectorId && !!date,
  })
}
```

Use type assertion via unknown for joined tables (consistent with 03-03 decision).
Handle PGRST116 gracefully (consistent with 04-02 pattern).
  </action>
  <verify>TypeScript compiles: cd apps/admin && npx tsc --noEmit</verify>
  <done>Hooks exported: useInspectors, useInspectorWorkload, useInspectorSchedule</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd apps/admin && npx tsc --noEmit` passes
- [ ] useInspectors hook fetches users with role='inspector'
- [ ] useInspectorWorkload aggregates inspection counts by inspector/date
- [ ] useInspectorSchedule fetches inspections for a specific inspector/date
</verification>

<success_criteria>
- All tasks completed
- TypeScript compiles without errors
- Hooks follow existing patterns (React Query, Supabase client)
- Workload calculation is correct
</success_criteria>

<output>
After completion, create `.planning/phases/06-smart-scheduling/06-02-SUMMARY.md`
</output>
