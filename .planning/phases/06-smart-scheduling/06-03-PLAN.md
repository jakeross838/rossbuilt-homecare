---
phase: 06-smart-scheduling
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - apps/admin/src/hooks/use-inspections.ts
autonomous: true
must_haves:
  truths:
    - "Can fetch inspections for calendar display"
    - "Can create a new inspection"
    - "Can update/reschedule an inspection"
    - "Can cancel an inspection"
  artifacts:
    - path: "apps/admin/src/hooks/use-inspections.ts"
      provides: "React Query hooks for inspection CRUD operations"
  key_links:
    - from: "use-inspections.ts mutations"
      to: "supabase inspections table"
      via: "insert/update operations"
    - from: "use-inspections.ts queries"
      to: "calendar components"
      via: "CalendarInspection type"
---

<objective>
Create React Query hooks for inspection CRUD operations needed by the calendar.

Purpose: Provide data layer for scheduling, viewing, and managing inspections.
Output: Complete set of hooks for inspection operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs
@.planning/phases/06-smart-scheduling/06-01-SUMMARY.md

# Database schema
@supabase/migrations/008_inspections.sql

# Existing hook patterns
@apps/admin/src/hooks/use-programs.ts
@apps/admin/src/hooks/use-equipment.ts

# Types and validation from 06-01
@apps/admin/src/lib/types/scheduling.ts
@apps/admin/src/lib/validations/inspection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create inspection query hooks</name>
  <files>apps/admin/src/hooks/use-inspections.ts</files>
  <action>
Create React Query hooks for fetching inspections:

```ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import type { Tables, InsertTables, UpdateTables } from '@/types/database.types'
import type { CalendarInspection } from '@/lib/types/scheduling'
import type { ScheduleInspectionInput, RescheduleInspectionInput } from '@/lib/validations/inspection'

type Inspection = Tables<'inspections'>

// Fetch inspections for a date range (calendar view)
export function useCalendarInspections(startDate: string, endDate: string) {
  return useQuery({
    queryKey: ['calendar-inspections', startDate, endDate],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('inspections')
        .select(`
          id,
          property_id,
          program_id,
          inspector_id,
          inspection_type,
          status,
          scheduled_date,
          scheduled_time_start,
          scheduled_time_end,
          estimated_duration_minutes,
          properties (
            id,
            name,
            address_line1,
            city
          ),
          users!inspections_inspector_id_fkey (
            id,
            full_name,
            email
          )
        `)
        .gte('scheduled_date', startDate)
        .lte('scheduled_date', endDate)
        .order('scheduled_date')
        .order('scheduled_time_start')

      if (error) throw error

      // Transform to CalendarInspection type
      return (data || []).map((row) => ({
        id: row.id,
        property_id: row.property_id,
        program_id: row.program_id,
        inspector_id: row.inspector_id,
        inspection_type: row.inspection_type,
        status: row.status,
        scheduled_date: row.scheduled_date,
        scheduled_time_start: row.scheduled_time_start,
        scheduled_time_end: row.scheduled_time_end,
        estimated_duration_minutes: row.estimated_duration_minutes,
        property: row.properties as unknown as CalendarInspection['property'],
        inspector: row.users as unknown as CalendarInspection['inspector'],
      })) as CalendarInspection[]
    },
    enabled: !!startDate && !!endDate,
  })
}

// Fetch single inspection by ID
export function useInspection(id: string | undefined) {
  return useQuery({
    queryKey: ['inspection', id],
    queryFn: async () => {
      if (!id) return null

      const { data, error } = await supabase
        .from('inspections')
        .select(`
          *,
          properties (
            id,
            name,
            address_line1,
            city,
            state,
            zip
          ),
          users!inspections_inspector_id_fkey (
            id,
            full_name,
            email
          ),
          programs (
            id,
            tier,
            frequency
          )
        `)
        .eq('id', id)
        .single()

      if (error) {
        if (error.code === 'PGRST116') return null
        throw error
      }
      return data
    },
    enabled: !!id,
  })
}

// Fetch inspections for a specific property
export function usePropertyInspections(propertyId: string | undefined) {
  return useQuery({
    queryKey: ['property-inspections', propertyId],
    queryFn: async () => {
      if (!propertyId) return []

      const { data, error } = await supabase
        .from('inspections')
        .select(`
          id,
          inspection_type,
          status,
          scheduled_date,
          scheduled_time_start,
          completed_at,
          users!inspections_inspector_id_fkey (
            id,
            full_name
          )
        `)
        .eq('property_id', propertyId)
        .order('scheduled_date', { ascending: false })
        .limit(10)

      if (error) throw error
      return data
    },
    enabled: !!propertyId,
  })
}
```

Use type assertion via unknown for joined tables (per 03-03 decision).
  </action>
  <verify>TypeScript compiles: cd apps/admin && npx tsc --noEmit</verify>
  <done>Query hooks exported: useCalendarInspections, useInspection, usePropertyInspections</done>
</task>

<task type="auto">
  <name>Task 2: Create inspection mutation hooks</name>
  <files>apps/admin/src/hooks/use-inspections.ts</files>
  <action>
Add mutation hooks to the same file:

```ts
// Schedule a new inspection
export function useScheduleInspection() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (input: ScheduleInspectionInput) => {
      // Get current user's org
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) throw new Error('Not authenticated')

      const { data: userData, error: userError } = await supabase
        .from('users')
        .select('organization_id')
        .eq('id', user.id)
        .single()

      if (userError) throw userError

      const insertData: InsertTables<'inspections'> = {
        organization_id: userData.organization_id,
        property_id: input.property_id,
        program_id: input.program_id || null,
        inspector_id: input.inspector_id || null,
        inspection_type: input.inspection_type,
        scheduled_date: input.scheduled_date,
        scheduled_time_start: input.scheduled_time_start || null,
        scheduled_time_end: input.scheduled_time_end || null,
        estimated_duration_minutes: input.estimated_duration_minutes || null,
        status: 'scheduled',
        checklist: {},
      }

      const { data, error } = await supabase
        .from('inspections')
        .insert(insertData)
        .select()
        .single()

      if (error) throw error
      return data
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['calendar-inspections'] })
      queryClient.invalidateQueries({ queryKey: ['property-inspections'] })
      queryClient.invalidateQueries({ queryKey: ['inspector-workload'] })
    },
  })
}

// Reschedule an inspection
export function useRescheduleInspection() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, ...input }: RescheduleInspectionInput & { id: string }) => {
      const updateData: UpdateTables<'inspections'> = {
        scheduled_date: input.scheduled_date,
        scheduled_time_start: input.scheduled_time_start || null,
        scheduled_time_end: input.scheduled_time_end || null,
        inspector_id: input.inspector_id || null,
        status: 'rescheduled',
        updated_at: new Date().toISOString(),
      }

      const { data, error } = await supabase
        .from('inspections')
        .update(updateData)
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return data
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['calendar-inspections'] })
      queryClient.invalidateQueries({ queryKey: ['inspection', variables.id] })
      queryClient.invalidateQueries({ queryKey: ['property-inspections'] })
      queryClient.invalidateQueries({ queryKey: ['inspector-workload'] })
    },
  })
}

// Cancel an inspection
export function useCancelInspection() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (id: string) => {
      const { data, error } = await supabase
        .from('inspections')
        .update({
          status: 'cancelled',
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return data
    },
    onSuccess: (_, id) => {
      queryClient.invalidateQueries({ queryKey: ['calendar-inspections'] })
      queryClient.invalidateQueries({ queryKey: ['inspection', id] })
      queryClient.invalidateQueries({ queryKey: ['property-inspections'] })
      queryClient.invalidateQueries({ queryKey: ['inspector-workload'] })
    },
  })
}

// Assign inspector to inspection
export function useAssignInspector() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ inspectionId, inspectorId }: { inspectionId: string; inspectorId: string | null }) => {
      const { data, error } = await supabase
        .from('inspections')
        .update({
          inspector_id: inspectorId,
          updated_at: new Date().toISOString(),
        })
        .eq('id', inspectionId)
        .select()
        .single()

      if (error) throw error
      return data
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['calendar-inspections'] })
      queryClient.invalidateQueries({ queryKey: ['inspection', variables.inspectionId] })
      queryClient.invalidateQueries({ queryKey: ['inspector-workload'] })
    },
  })
}
```

Follow the patterns from use-programs.ts for mutations with query invalidation.
  </action>
  <verify>TypeScript compiles: cd apps/admin && npx tsc --noEmit</verify>
  <done>Mutation hooks exported: useScheduleInspection, useRescheduleInspection, useCancelInspection, useAssignInspector</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd apps/admin && npx tsc --noEmit` passes
- [ ] useCalendarInspections fetches inspections for date range with property/inspector joins
- [ ] useScheduleInspection creates new inspection with all required fields
- [ ] useRescheduleInspection updates date/time/inspector
- [ ] useCancelInspection sets status to 'cancelled'
- [ ] All mutations invalidate relevant query caches
</verification>

<success_criteria>
- All tasks completed
- TypeScript compiles without errors
- Hooks follow existing mutation patterns (per 04-02, 04-04)
- Query invalidation covers all affected data
</success_criteria>

<output>
After completion, create `.planning/phases/06-smart-scheduling/06-03-SUMMARY.md`
</output>
