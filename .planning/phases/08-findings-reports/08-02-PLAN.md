---
phase: 08-findings-reports
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/admin/src/lib/validations/report.ts
  - apps/admin/src/hooks/use-recommendations.ts
  - apps/admin/src/hooks/use-reports.ts
autonomous: true
must_haves:
  truths:
    - "Hooks fetch inspection details with recommendations"
    - "Report data is aggregated from multiple sources"
    - "Validation schemas ensure data integrity"
  artifacts:
    - path: "apps/admin/src/lib/validations/report.ts"
      provides: "Zod schemas for report validation"
    - path: "apps/admin/src/hooks/use-recommendations.ts"
      provides: "React Query hooks for recommendations"
    - path: "apps/admin/src/hooks/use-reports.ts"
      provides: "React Query hooks for report generation"
  key_links:
    - from: "use-reports.ts"
      to: "use-recommendations.ts"
      via: "aggregates data for reports"
    - from: "use-reports.ts"
      to: "use-inspections.ts"
      via: "fetches inspection details"
---

<objective>
Create validation schemas and React Query hooks for report data fetching.

Purpose: Provide data access layer for report generation.
Output: Hooks for fetching recommendations and building report data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Report types
@apps/admin/src/lib/types/report.ts
@apps/admin/src/lib/constants/report.ts

# Existing hooks pattern
@apps/admin/src/hooks/use-inspections.ts
@apps/admin/src/hooks/use-inspection-execution.ts

# Database types
@apps/admin/src/lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create report validation schemas</name>
  <files>apps/admin/src/lib/validations/report.ts</files>
  <action>
Create apps/admin/src/lib/validations/report.ts:

```tsx
import { z } from 'zod'

// Report generation options schema
export const reportOptionsSchema = z.object({
  include_photos: z.boolean().default(true),
  include_recommendations: z.boolean().default(true),
  include_ai_summary: z.boolean().default(true),
  include_weather: z.boolean().default(true),
  photo_quality: z.enum(['thumbnail', 'medium', 'full']).default('medium'),
  page_size: z.enum(['letter', 'a4']).default('letter'),
})

export type ReportOptionsInput = z.infer<typeof reportOptionsSchema>

// Report delivery options schema
export const reportDeliverySchema = z.object({
  send_email: z.boolean().default(false),
  email_to: z.array(z.string().email()).default([]),
  email_subject: z.string().optional(),
  email_message: z.string().optional(),
})

export type ReportDeliveryInput = z.infer<typeof reportDeliverySchema>

// Generate report request schema
export const generateReportSchema = z.object({
  inspection_id: z.string().uuid(),
  options: reportOptionsSchema.partial().optional(),
  delivery: reportDeliverySchema.partial().optional(),
})

export type GenerateReportInput = z.infer<typeof generateReportSchema>

// Email report schema
export const emailReportSchema = z.object({
  report_id: z.string().uuid(),
  to: z.array(z.string().email()).min(1, 'At least one email required'),
  subject: z.string().min(1, 'Subject required'),
  message: z.string().optional(),
})

export type EmailReportInput = z.infer<typeof emailReportSchema>
```
  </action>
  <verify>TypeScript compiles: cd apps/admin && npx tsc --noEmit</verify>
  <done>Report validation schemas</done>
</task>

<task type="auto">
  <name>Task 2: Create recommendations hooks</name>
  <files>apps/admin/src/hooks/use-recommendations.ts</files>
  <action>
Create apps/admin/src/hooks/use-recommendations.ts:

```tsx
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import type { Tables, InsertTables, UpdateTables } from '@/lib/supabase'

type Recommendation = Tables<'recommendations'>
type RecommendationInsert = InsertTables<'recommendations'>
type RecommendationUpdate = UpdateTables<'recommendations'>

// Fetch recommendations for an inspection
export function useInspectionRecommendations(inspectionId: string | undefined) {
  return useQuery({
    queryKey: ['recommendations', 'inspection', inspectionId],
    queryFn: async () => {
      if (!inspectionId) return []

      const { data, error } = await supabase
        .from('recommendations')
        .select('*')
        .eq('inspection_id', inspectionId)
        .order('priority', { ascending: false })
        .order('created_at', { ascending: true })

      if (error) throw error
      return data as Recommendation[]
    },
    enabled: !!inspectionId,
  })
}

// Fetch recommendations for a property
export function usePropertyRecommendations(propertyId: string | undefined) {
  return useQuery({
    queryKey: ['recommendations', 'property', propertyId],
    queryFn: async () => {
      if (!propertyId) return []

      const { data, error } = await supabase
        .from('recommendations')
        .select(`
          *,
          inspection:inspections(scheduled_date, inspection_type)
        `)
        .eq('property_id', propertyId)
        .order('created_at', { ascending: false })

      if (error) throw error
      return data
    },
    enabled: !!propertyId,
  })
}

// Fetch a single recommendation
export function useRecommendation(id: string | undefined) {
  return useQuery({
    queryKey: ['recommendation', id],
    queryFn: async () => {
      if (!id) return null

      const { data, error } = await supabase
        .from('recommendations')
        .select('*')
        .eq('id', id)
        .single()

      if (error) throw error
      return data as Recommendation
    },
    enabled: !!id,
  })
}

// Create a recommendation
export function useCreateRecommendation() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (input: RecommendationInsert) => {
      const { data, error } = await supabase
        .from('recommendations')
        .insert(input)
        .select()
        .single()

      if (error) throw error
      return data as Recommendation
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['recommendations'] })
      if (data.inspection_id) {
        queryClient.invalidateQueries({
          queryKey: ['recommendations', 'inspection', data.inspection_id],
        })
      }
      if (data.property_id) {
        queryClient.invalidateQueries({
          queryKey: ['recommendations', 'property', data.property_id],
        })
      }
    },
  })
}

// Update a recommendation
export function useUpdateRecommendation() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, ...input }: RecommendationUpdate & { id: string }) => {
      const { data, error } = await supabase
        .from('recommendations')
        .update({ ...input, updated_at: new Date().toISOString() })
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return data as Recommendation
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['recommendations'] })
      queryClient.invalidateQueries({ queryKey: ['recommendation', data.id] })
    },
  })
}

// Update recommendation status
export function useUpdateRecommendationStatus() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({
      id,
      status,
    }: {
      id: string
      status: Recommendation['status']
    }) => {
      const { data, error } = await supabase
        .from('recommendations')
        .update({
          status,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return data as Recommendation
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['recommendations'] })
      queryClient.invalidateQueries({ queryKey: ['recommendation', data.id] })
    },
  })
}

// Delete a recommendation
export function useDeleteRecommendation() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from('recommendations')
        .delete()
        .eq('id', id)

      if (error) throw error
      return id
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['recommendations'] })
    },
  })
}
```
  </action>
  <verify>TypeScript compiles: cd apps/admin && npx tsc --noEmit</verify>
  <done>Recommendations hooks with CRUD operations</done>
</task>

<task type="auto">
  <name>Task 3: Create reports hooks</name>
  <files>apps/admin/src/hooks/use-reports.ts</files>
  <action>
Create apps/admin/src/hooks/use-reports.ts:

```tsx
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import type {
  InspectionReport,
  ReportFindingSummary,
  ReportSectionFindings,
  ReportRecommendation,
} from '@/lib/types/report'
import type { InspectorInspection, ChecklistItemFinding } from '@/lib/types/inspector'
import type { Tables } from '@/lib/supabase'
import { FINDING_STATUS_COLORS, CONDITION_LABELS } from '@/lib/constants/report'

type Inspection = Tables<'inspections'>
type Recommendation = Tables<'recommendations'>
type User = Tables<'users'>

// Fetch full inspection data for report generation
export function useInspectionForReport(inspectionId: string | undefined) {
  return useQuery({
    queryKey: ['inspection-report-data', inspectionId],
    queryFn: async () => {
      if (!inspectionId) return null

      // Fetch inspection with related data
      const { data: inspection, error: inspectionError } = await supabase
        .from('inspections')
        .select(`
          *,
          property:properties(
            id, name, address_line1, address_line2, city, state, zip,
            primary_photo_url,
            client:clients(id, first_name, last_name, email, phone)
          ),
          inspector:users(id, first_name, last_name)
        `)
        .eq('id', inspectionId)
        .single()

      if (inspectionError) throw inspectionError

      // Fetch recommendations for this inspection
      const { data: recommendations, error: recError } = await supabase
        .from('recommendations')
        .select('*')
        .eq('inspection_id', inspectionId)
        .order('priority', { ascending: false })

      if (recError) throw recError

      // Fetch photos
      const { data: photos, error: photoError } = await supabase
        .from('inspection_photos')
        .select('*')
        .eq('inspection_id', inspectionId)
        .order('display_order')

      if (photoError) throw photoError

      return {
        inspection,
        recommendations: recommendations || [],
        photos: photos || [],
      }
    },
    enabled: !!inspectionId,
  })
}

// Build report data from inspection
export function useBuildReportData(inspectionId: string | undefined) {
  const { data, isLoading, error } = useInspectionForReport(inspectionId)

  const reportData = data ? buildReportData(data) : null

  return {
    data: reportData,
    isLoading,
    error,
  }
}

// Helper to build report data structure
function buildReportData(data: {
  inspection: unknown
  recommendations: Recommendation[]
  photos: Tables<'inspection_photos'>[]
}): InspectionReport {
  const inspection = data.inspection as Inspection & {
    property: {
      id: string
      name: string
      address_line1: string
      address_line2: string | null
      city: string
      state: string
      zip: string
      primary_photo_url: string | null
      client: {
        id: string
        first_name: string
        last_name: string
        email: string | null
        phone: string | null
      }
    }
    inspector: { id: string; first_name: string; last_name: string }
  }

  const checklist = (inspection.checklist || { sections: [] }) as unknown as {
    sections: Array<{
      id: string
      title: string
      items: Array<{ id: string; label: string }>
    }>
  }
  const findings = (inspection.findings || {}) as Record<string, ChecklistItemFinding>

  // Calculate findings summary
  const findingsSummary = calculateFindingsSummary(checklist, findings)

  // Build section findings
  const sections = buildSectionFindings(checklist, findings)

  // Build recommendations
  const recommendations = buildRecommendations(data.recommendations)

  // Build all photos list
  const allPhotos = buildPhotoList(data.photos, findings)

  return {
    id: crypto.randomUUID(),
    inspection_id: inspection.id,
    generated_at: new Date().toISOString(),
    status: 'pending',

    inspection_date: inspection.scheduled_date,
    inspection_type: inspection.inspection_type || 'scheduled',
    tier: 'comprehensive', // Would come from program
    duration_minutes: inspection.actual_duration_minutes || inspection.estimated_duration_minutes || 0,

    property: {
      id: inspection.property.id,
      name: inspection.property.name,
      address: [inspection.property.address_line1, inspection.property.address_line2]
        .filter(Boolean)
        .join(', '),
      city: inspection.property.city,
      state: inspection.property.state,
      zip: inspection.property.zip,
      photo_url: inspection.property.primary_photo_url || undefined,
    },

    client: {
      id: inspection.property.client.id,
      name: `${inspection.property.client.first_name} ${inspection.property.client.last_name}`,
      email: inspection.property.client.email || undefined,
      phone: inspection.property.client.phone || undefined,
    },

    inspector: {
      id: inspection.inspector.id,
      name: `${inspection.inspector.first_name} ${inspection.inspector.last_name}`,
    },

    overall_condition: inspection.overall_condition,
    summary: inspection.summary || 'No summary provided.',
    weather: inspection.weather_conditions as InspectionReport['weather'],

    findings_summary: findingsSummary,
    sections,
    recommendations,

    cover_photo: inspection.property.primary_photo_url || undefined,
    all_photos: allPhotos,
  }
}

function calculateFindingsSummary(
  checklist: { sections: Array<{ items: Array<{ id: string }> }> },
  findings: Record<string, ChecklistItemFinding>
): ReportFindingSummary {
  let total = 0
  let passed = 0
  let failed = 0
  let needsAttention = 0
  let urgent = 0
  let notApplicable = 0

  for (const section of checklist.sections || []) {
    for (const item of section.items || []) {
      total++
      const finding = findings[item.id]
      if (finding) {
        switch (finding.status) {
          case 'pass':
            passed++
            break
          case 'fail':
            failed++
            break
          case 'needs_attention':
            needsAttention++
            break
          case 'urgent':
            urgent++
            break
          case 'na':
            notApplicable++
            break
        }
      }
    }
  }

  return {
    total_items: total,
    passed,
    failed,
    needs_attention: needsAttention,
    urgent,
    not_applicable: notApplicable,
    completion_percentage: total > 0 ? Math.round((Object.keys(findings).length / total) * 100) : 0,
  }
}

function buildSectionFindings(
  checklist: {
    sections: Array<{ id: string; title: string; items: Array<{ id: string; label: string }> }>
  },
  findings: Record<string, ChecklistItemFinding>
): ReportSectionFindings[] {
  return (checklist.sections || []).map((section) => {
    const items = (section.items || []).map((item) => {
      const finding = findings[item.id]
      return {
        item_id: item.id,
        label: item.label,
        status: finding?.status || 'na',
        notes: finding?.notes,
        photos: finding?.photos || [],
        recommendation_added: finding?.recommendation_added || false,
      }
    })

    const issues = items.filter((i) =>
      ['fail', 'needs_attention', 'urgent'].includes(i.status)
    ).length

    return {
      section_id: section.id,
      section_name: section.title,
      items,
      summary: {
        total: items.length,
        passed: items.filter((i) => i.status === 'pass').length,
        issues,
      },
    }
  })
}

function buildRecommendations(recommendations: Recommendation[]): ReportRecommendation[] {
  return recommendations.map((rec) => ({
    id: rec.id,
    title: rec.title,
    description: rec.description,
    priority: rec.priority,
    category: rec.category || undefined,
    photos: (rec.photos as string[]) || [],
    estimated_cost_low: rec.estimated_cost_low
      ? parseFloat(rec.estimated_cost_low as unknown as string)
      : undefined,
    estimated_cost_high: rec.estimated_cost_high
      ? parseFloat(rec.estimated_cost_high as unknown as string)
      : undefined,
    ai_why_it_matters: rec.ai_why_it_matters || undefined,
  }))
}

function buildPhotoList(
  photos: Tables<'inspection_photos'>[],
  findings: Record<string, ChecklistItemFinding>
): InspectionReport['all_photos'] {
  const photoList: InspectionReport['all_photos'] = []

  // Add photos from inspection_photos table
  for (const photo of photos) {
    photoList.push({
      url: photo.url,
      caption: photo.caption || undefined,
      section: photo.section_id || undefined,
      item_label: photo.item_id || undefined,
    })
  }

  // Add photos from findings (embedded in JSONB)
  for (const [itemId, finding] of Object.entries(findings)) {
    for (const photoUrl of finding.photos || []) {
      if (!photoList.some((p) => p.url === photoUrl)) {
        photoList.push({
          url: photoUrl,
          item_label: itemId,
        })
      }
    }
  }

  return photoList
}

// Save report URL to inspection
export function useSaveReportUrl() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({
      inspectionId,
      reportUrl,
    }: {
      inspectionId: string
      reportUrl: string
    }) => {
      const { data, error } = await supabase
        .from('inspections')
        .update({
          report_url: reportUrl,
          report_generated_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        })
        .eq('id', inspectionId)
        .select()
        .single()

      if (error) throw error
      return data
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['inspection-report-data', data.id] })
      queryClient.invalidateQueries({ queryKey: ['inspections'] })
    },
  })
}

// Mark report as sent
export function useMarkReportSent() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (inspectionId: string) => {
      const { data, error } = await supabase
        .from('inspections')
        .update({
          report_sent_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        })
        .eq('id', inspectionId)
        .select()
        .single()

      if (error) throw error
      return data
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['inspections'] })
    },
  })
}
```
  </action>
  <verify>TypeScript compiles: cd apps/admin && npx tsc --noEmit</verify>
  <done>Reports hooks with data aggregation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd apps/admin && npx tsc --noEmit` passes
- [ ] Hooks fetch inspection with related data
- [ ] Report data structure is complete
- [ ] Recommendations can be fetched and updated
</verification>

<success_criteria>
- All tasks completed
- TypeScript compiles without errors
- Report data can be built from inspection
- Hooks follow React Query patterns
</success_criteria>

<output>
After completion, create `.planning/phases/08-findings-reports/08-02-SUMMARY.md`
</output>
