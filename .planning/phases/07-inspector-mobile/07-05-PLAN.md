---
phase: 07-inspector-mobile
plan: 05
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - apps/admin/src/lib/offline/photos.ts
  - apps/admin/src/hooks/use-photo-capture.ts
autonomous: true
must_haves:
  truths:
    - "Inspector can capture photos using device camera"
    - "Photos are stored locally before upload"
    - "Photos sync to Supabase storage when online"
  artifacts:
    - path: "apps/admin/src/lib/offline/photos.ts"
      provides: "Photo storage and upload queue"
    - path: "apps/admin/src/hooks/use-photo-capture.ts"
      provides: "React hook for camera access and photo capture"
  key_links:
    - from: "use-photo-capture.ts"
      to: "offline/photos.ts"
      via: "stores captured photos locally"
    - from: "offline/photos.ts"
      to: "Supabase Storage"
      via: "uploads to inspection-photos bucket"
---

<objective>
Create photo capture functionality with offline storage and background upload.

Purpose: Enable inspectors to document findings with photos even when offline.
Output: Hooks for camera access, local storage, and sync to cloud storage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs
@.planning/phases/07-inspector-mobile/07-01-SUMMARY.md
@.planning/phases/07-inspector-mobile/07-03-SUMMARY.md

# Offline infrastructure
@apps/admin/src/lib/offline/db.ts

# Constants
@apps/admin/src/lib/constants/inspector.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create photo storage and upload utilities</name>
  <files>apps/admin/src/lib/offline/photos.ts</files>
  <action>
Create apps/admin/src/lib/offline/photos.ts:

```ts
import { supabase } from '@/lib/supabase'
import { openDB, type IDBPDatabase } from 'idb'

const DB_NAME = 'rossbuilt-photos'
const DB_VERSION = 1
const STORE_NAME = 'pending-photos'

interface PendingPhoto {
  id: string
  inspectionId: string
  itemId: string
  blob: Blob
  filename: string
  createdAt: string
  uploadAttempts: number
}

let dbPromise: Promise<IDBPDatabase> | null = null

function getDB() {
  if (!dbPromise) {
    dbPromise = openDB(DB_NAME, DB_VERSION, {
      upgrade(db) {
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' })
          store.createIndex('by-inspection', 'inspectionId')
          store.createIndex('by-item', ['inspectionId', 'itemId'])
        }
      },
    })
  }
  return dbPromise
}

// Generate unique ID for photo
function generatePhotoId(): string {
  return `photo_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`
}

// Save photo blob locally
export async function savePhotoLocally(
  inspectionId: string,
  itemId: string,
  blob: Blob,
  filename: string
): Promise<string> {
  const db = await getDB()
  const id = generatePhotoId()

  const photo: PendingPhoto = {
    id,
    inspectionId,
    itemId,
    blob,
    filename,
    createdAt: new Date().toISOString(),
    uploadAttempts: 0,
  }

  await db.put(STORE_NAME, photo)
  return id
}

// Get all pending photos for an inspection
export async function getPendingPhotos(inspectionId: string): Promise<PendingPhoto[]> {
  const db = await getDB()
  return db.getAllFromIndex(STORE_NAME, 'by-inspection', inspectionId)
}

// Get pending photos for a specific checklist item
export async function getItemPendingPhotos(
  inspectionId: string,
  itemId: string
): Promise<PendingPhoto[]> {
  const db = await getDB()
  return db.getAllFromIndex(STORE_NAME, 'by-item', [inspectionId, itemId])
}

// Create object URL for local photo preview
export function createPhotoPreviewUrl(blob: Blob): string {
  return URL.createObjectURL(blob)
}

// Upload a single photo to Supabase storage
export async function uploadPhoto(photo: PendingPhoto): Promise<string | null> {
  try {
    const path = `inspections/${photo.inspectionId}/${photo.itemId}/${photo.filename}`

    const { error } = await supabase.storage
      .from('inspection-photos')
      .upload(path, photo.blob, {
        contentType: photo.blob.type,
        upsert: true,
      })

    if (error) throw error

    // Get public URL
    const { data: urlData } = supabase.storage
      .from('inspection-photos')
      .getPublicUrl(path)

    return urlData.publicUrl
  } catch (err) {
    console.error('Photo upload failed:', err)
    return null
  }
}

// Upload all pending photos and return uploaded URLs
export async function syncPendingPhotos(): Promise<{
  uploaded: number
  failed: number
  urls: Record<string, string[]> // itemId -> urls
}> {
  if (!navigator.onLine) {
    return { uploaded: 0, failed: 0, urls: {} }
  }

  const db = await getDB()
  const allPhotos = await db.getAll(STORE_NAME)

  let uploaded = 0
  let failed = 0
  const urls: Record<string, string[]> = {}

  for (const photo of allPhotos) {
    const url = await uploadPhoto(photo)

    if (url) {
      // Success - remove from local storage
      await db.delete(STORE_NAME, photo.id)
      uploaded++

      // Track URL by itemId
      if (!urls[photo.itemId]) {
        urls[photo.itemId] = []
      }
      urls[photo.itemId].push(url)
    } else {
      // Failed - increment attempt counter
      photo.uploadAttempts++
      await db.put(STORE_NAME, photo)
      failed++
    }
  }

  return { uploaded, failed, urls }
}

// Get count of pending photos
export async function getPendingPhotoCount(): Promise<number> {
  const db = await getDB()
  return db.count(STORE_NAME)
}

// Delete a local photo (before upload)
export async function deleteLocalPhoto(photoId: string): Promise<void> {
  const db = await getDB()
  await db.delete(STORE_NAME, photoId)
}

// Compress image blob for storage efficiency
export async function compressImage(
  blob: Blob,
  maxWidth = 1920,
  quality = 0.8
): Promise<Blob> {
  return new Promise((resolve, reject) => {
    const img = new Image()
    const url = URL.createObjectURL(blob)

    img.onload = () => {
      URL.revokeObjectURL(url)

      // Calculate dimensions
      let width = img.width
      let height = img.height

      if (width > maxWidth) {
        height = (height * maxWidth) / width
        width = maxWidth
      }

      // Draw to canvas
      const canvas = document.createElement('canvas')
      canvas.width = width
      canvas.height = height

      const ctx = canvas.getContext('2d')
      if (!ctx) {
        reject(new Error('Could not get canvas context'))
        return
      }

      ctx.drawImage(img, 0, 0, width, height)

      // Convert to blob
      canvas.toBlob(
        (result) => {
          if (result) {
            resolve(result)
          } else {
            reject(new Error('Failed to compress image'))
          }
        },
        'image/jpeg',
        quality
      )
    }

    img.onerror = () => {
      URL.revokeObjectURL(url)
      reject(new Error('Failed to load image'))
    }

    img.src = url
  })
}
```
  </action>
  <verify>TypeScript compiles: cd apps/admin && npx tsc --noEmit</verify>
  <done>Photo storage with IndexedDB and Supabase upload</done>
</task>

<task type="auto">
  <name>Task 2: Create photo capture hook</name>
  <files>apps/admin/src/hooks/use-photo-capture.ts</files>
  <action>
Create apps/admin/src/hooks/use-photo-capture.ts:

```ts
import { useState, useCallback, useRef } from 'react'
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import {
  savePhotoLocally,
  getItemPendingPhotos,
  deleteLocalPhoto,
  compressImage,
  createPhotoPreviewUrl,
  syncPendingPhotos,
} from '@/lib/offline/photos'
import { PHOTO_LIMITS } from '@/lib/constants/inspector'

interface LocalPhoto {
  id: string
  previewUrl: string
  isLocal: true
}

interface UploadedPhoto {
  url: string
  isLocal: false
}

type Photo = LocalPhoto | UploadedPhoto

// Hook for capturing and managing photos for a checklist item
export function usePhotoCapture(inspectionId: string, itemId: string) {
  const queryClient = useQueryClient()
  const fileInputRef = useRef<HTMLInputElement>(null)
  const [isCapturing, setIsCapturing] = useState(false)

  // Get pending local photos for this item
  const { data: localPhotos = [] } = useQuery({
    queryKey: ['local-photos', inspectionId, itemId],
    queryFn: async () => {
      const pending = await getItemPendingPhotos(inspectionId, itemId)
      return pending.map((p) => ({
        id: p.id,
        previewUrl: createPhotoPreviewUrl(p.blob),
        isLocal: true as const,
      }))
    },
  })

  // Capture photo from camera
  const capturePhoto = useMutation({
    mutationFn: async (file: File) => {
      // Validate file type
      if (!PHOTO_LIMITS.ACCEPTED_TYPES.includes(file.type)) {
        throw new Error('Invalid file type. Please use JPEG, PNG, or WebP.')
      }

      // Validate file size
      if (file.size > PHOTO_LIMITS.MAX_FILE_SIZE_MB * 1024 * 1024) {
        throw new Error(`File too large. Maximum size is ${PHOTO_LIMITS.MAX_FILE_SIZE_MB}MB.`)
      }

      // Compress the image
      const compressed = await compressImage(file)

      // Generate filename
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
      const filename = `${itemId}_${timestamp}.jpg`

      // Save locally
      const photoId = await savePhotoLocally(inspectionId, itemId, compressed, filename)

      return photoId
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['local-photos', inspectionId, itemId] })
    },
  })

  // Delete a local photo
  const deletePhoto = useMutation({
    mutationFn: async (photoId: string) => {
      await deleteLocalPhoto(photoId)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['local-photos', inspectionId, itemId] })
    },
  })

  // Open camera/file picker
  const openCamera = useCallback(() => {
    if (localPhotos.length >= PHOTO_LIMITS.MAX_PHOTOS_PER_ITEM) {
      alert(`Maximum ${PHOTO_LIMITS.MAX_PHOTOS_PER_ITEM} photos per item.`)
      return
    }
    fileInputRef.current?.click()
  }, [localPhotos.length])

  // Handle file selection
  const handleFileChange = useCallback(
    async (event: React.ChangeEvent<HTMLInputElement>) => {
      const file = event.target.files?.[0]
      if (!file) return

      setIsCapturing(true)
      try {
        await capturePhoto.mutateAsync(file)
      } catch (err) {
        console.error('Failed to capture photo:', err)
        alert(err instanceof Error ? err.message : 'Failed to capture photo')
      } finally {
        setIsCapturing(false)
        // Reset input so same file can be selected again
        if (fileInputRef.current) {
          fileInputRef.current.value = ''
        }
      }
    },
    [capturePhoto]
  )

  return {
    photos: localPhotos,
    isCapturing,
    canAddMore: localPhotos.length < PHOTO_LIMITS.MAX_PHOTOS_PER_ITEM,
    openCamera,
    deletePhoto: deletePhoto.mutate,
    fileInputRef,
    handleFileChange,
    maxPhotos: PHOTO_LIMITS.MAX_PHOTOS_PER_ITEM,
  }
}

// Hook for syncing all pending photos
export function usePhotoSync() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: syncPendingPhotos,
    onSuccess: (result) => {
      // Invalidate all local photo queries
      queryClient.invalidateQueries({ queryKey: ['local-photos'] })

      if (result.uploaded > 0) {
        console.log(`Synced ${result.uploaded} photos`)
      }
      if (result.failed > 0) {
        console.warn(`Failed to sync ${result.failed} photos`)
      }
    },
  })
}

// Camera input component helper
export function CameraInput({
  inputRef,
  onChange,
}: {
  inputRef: React.RefObject<HTMLInputElement>
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void
}) {
  return (
    <input
      ref={inputRef}
      type="file"
      accept="image/jpeg,image/png,image/webp"
      capture="environment" // Use back camera on mobile
      onChange={onChange}
      className="hidden"
    />
  )
}
```
  </action>
  <verify>TypeScript compiles: cd apps/admin && npx tsc --noEmit</verify>
  <done>Photo capture hook with camera access and local storage</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd apps/admin && npx tsc --noEmit` passes
- [ ] Photo storage uses IndexedDB
- [ ] Compression reduces image size
- [ ] Upload to Supabase storage works
- [ ] Hook provides camera access
</verification>

<success_criteria>
- All tasks completed
- TypeScript compiles without errors
- Photos stored locally first (offline-first)
- Background upload to Supabase storage
- Camera capture works on mobile
</success_criteria>

<output>
After completion, create `.planning/phases/07-inspector-mobile/07-05-SUMMARY.md`
</output>
