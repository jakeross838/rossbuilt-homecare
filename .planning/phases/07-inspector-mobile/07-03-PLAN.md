---
phase: 07-inspector-mobile
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - apps/admin/src/lib/offline/db.ts
  - apps/admin/src/lib/offline/sync.ts
  - apps/admin/src/hooks/use-offline.ts
autonomous: true
must_haves:
  truths:
    - "IndexedDB stores inspection data offline"
    - "App detects online/offline status"
    - "Pending changes queue for sync when online"
  artifacts:
    - path: "apps/admin/src/lib/offline/db.ts"
      provides: "IndexedDB wrapper with typed stores"
    - path: "apps/admin/src/lib/offline/sync.ts"
      provides: "Sync queue and background sync logic"
    - path: "apps/admin/src/hooks/use-offline.ts"
      provides: "React hook for offline state"
  key_links:
    - from: "db.ts"
      to: "IndexedDB"
      via: "idb library operations"
    - from: "sync.ts"
      to: "Supabase API"
      via: "batch updates when online"
---

<objective>
Create IndexedDB storage layer for offline inspection data and sync queue.

Purpose: Enable inspectors to complete inspections without network connectivity.
Output: Offline storage with automatic sync when connection restored.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs
@.planning/phases/07-inspector-mobile/07-01-SUMMARY.md

# Types from 07-02
@apps/admin/src/lib/types/inspector.ts
@apps/admin/src/lib/constants/inspector.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install idb and create IndexedDB wrapper</name>
  <files>apps/admin/package.json, apps/admin/src/lib/offline/db.ts</files>
  <action>
1. Install idb library (tiny IndexedDB wrapper):
   ```bash
   cd apps/admin && npm install idb
   ```

2. Create apps/admin/src/lib/offline/db.ts:

```ts
import { openDB, DBSchema, IDBPDatabase } from 'idb'
import type { InspectorInspection, ChecklistItemFinding } from '@/lib/types/inspector'

// Database schema definition
interface OfflineDB extends DBSchema {
  // Cached inspections for offline access
  inspections: {
    key: string // inspection id
    value: {
      data: InspectorInspection
      cached_at: string
      expires_at: string
    }
    indexes: {
      'by-date': string
      'by-status': string
    }
  }
  // Pending findings updates to sync
  pendingFindings: {
    key: string // `${inspection_id}:${item_id}`
    value: {
      inspection_id: string
      item_id: string
      finding: ChecklistItemFinding
      created_at: string
      synced: boolean
    }
    indexes: {
      'by-inspection': string
      'by-synced': number // 0 or 1
    }
  }
  // Pending photos to upload
  pendingPhotos: {
    key: string // UUID
    value: {
      id: string
      inspection_id: string
      item_id: string
      blob: Blob
      filename: string
      created_at: string
      uploaded: boolean
      upload_url?: string
    }
    indexes: {
      'by-inspection': string
      'by-uploaded': number
    }
  }
  // Inspection completion to sync
  pendingCompletions: {
    key: string // inspection_id
    value: {
      inspection_id: string
      overall_condition: string
      summary: string
      completed_at: string
      synced: boolean
    }
  }
  // Sync metadata
  syncMeta: {
    key: string
    value: {
      key: string
      value: string | number
      updated_at: string
    }
  }
}

const DB_NAME = 'rossbuilt-offline'
const DB_VERSION = 1

let dbInstance: IDBPDatabase<OfflineDB> | null = null

export async function getDB(): Promise<IDBPDatabase<OfflineDB>> {
  if (dbInstance) return dbInstance

  dbInstance = await openDB<OfflineDB>(DB_NAME, DB_VERSION, {
    upgrade(db) {
      // Inspections store
      if (!db.objectStoreNames.contains('inspections')) {
        const inspectionStore = db.createObjectStore('inspections', { keyPath: 'data.id' })
        inspectionStore.createIndex('by-date', 'data.scheduled_date')
        inspectionStore.createIndex('by-status', 'data.status')
      }

      // Pending findings store
      if (!db.objectStoreNames.contains('pendingFindings')) {
        const findingsStore = db.createObjectStore('pendingFindings')
        findingsStore.createIndex('by-inspection', 'inspection_id')
        findingsStore.createIndex('by-synced', 'synced')
      }

      // Pending photos store
      if (!db.objectStoreNames.contains('pendingPhotos')) {
        const photosStore = db.createObjectStore('pendingPhotos', { keyPath: 'id' })
        photosStore.createIndex('by-inspection', 'inspection_id')
        photosStore.createIndex('by-uploaded', 'uploaded')
      }

      // Pending completions store
      if (!db.objectStoreNames.contains('pendingCompletions')) {
        db.createObjectStore('pendingCompletions', { keyPath: 'inspection_id' })
      }

      // Sync metadata store
      if (!db.objectStoreNames.contains('syncMeta')) {
        db.createObjectStore('syncMeta', { keyPath: 'key' })
      }
    },
  })

  return dbInstance
}

// Inspection cache operations
export async function cacheInspection(inspection: InspectorInspection): Promise<void> {
  const db = await getDB()
  const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString() // 24 hours
  await db.put('inspections', {
    data: inspection,
    cached_at: new Date().toISOString(),
    expires_at: expiresAt,
  })
}

export async function getCachedInspection(id: string): Promise<InspectorInspection | null> {
  const db = await getDB()
  const cached = await db.get('inspections', id)
  if (!cached) return null

  // Check if expired
  if (new Date(cached.expires_at) < new Date()) {
    await db.delete('inspections', id)
    return null
  }

  return cached.data
}

export async function getCachedInspectionsForDate(date: string): Promise<InspectorInspection[]> {
  const db = await getDB()
  const cached = await db.getAllFromIndex('inspections', 'by-date', date)
  const now = new Date()

  return cached
    .filter(c => new Date(c.expires_at) > now)
    .map(c => c.data)
}

// Pending findings operations
export async function savePendingFinding(
  inspectionId: string,
  itemId: string,
  finding: ChecklistItemFinding
): Promise<void> {
  const db = await getDB()
  const key = `${inspectionId}:${itemId}`
  await db.put('pendingFindings', {
    inspection_id: inspectionId,
    item_id: itemId,
    finding,
    created_at: new Date().toISOString(),
    synced: false,
  }, key)
}

export async function getPendingFindings(inspectionId: string): Promise<Array<{
  item_id: string
  finding: ChecklistItemFinding
}>> {
  const db = await getDB()
  const pending = await db.getAllFromIndex('pendingFindings', 'by-inspection', inspectionId)
  return pending.map(p => ({ item_id: p.item_id, finding: p.finding }))
}

export async function getUnsyncedFindings(): Promise<Array<{
  inspection_id: string
  item_id: string
  finding: ChecklistItemFinding
}>> {
  const db = await getDB()
  const all = await db.getAll('pendingFindings')
  return all.filter(p => !p.synced)
}

export async function markFindingsSynced(keys: string[]): Promise<void> {
  const db = await getDB()
  const tx = db.transaction('pendingFindings', 'readwrite')
  for (const key of keys) {
    const item = await tx.store.get(key)
    if (item) {
      await tx.store.put({ ...item, synced: true }, key)
    }
  }
  await tx.done
}

// Pending photo operations
export async function savePendingPhoto(
  inspectionId: string,
  itemId: string,
  blob: Blob,
  filename: string
): Promise<string> {
  const db = await getDB()
  const id = crypto.randomUUID()
  await db.put('pendingPhotos', {
    id,
    inspection_id: inspectionId,
    item_id: itemId,
    blob,
    filename,
    created_at: new Date().toISOString(),
    uploaded: false,
  })
  return id
}

export async function getUnsyncedPhotos(): Promise<Array<{
  id: string
  inspection_id: string
  item_id: string
  blob: Blob
  filename: string
}>> {
  const db = await getDB()
  const all = await db.getAll('pendingPhotos')
  return all.filter(p => !p.uploaded)
}

export async function markPhotoUploaded(id: string, url: string): Promise<void> {
  const db = await getDB()
  const photo = await db.get('pendingPhotos', id)
  if (photo) {
    await db.put('pendingPhotos', { ...photo, uploaded: true, upload_url: url })
  }
}

// Sync metadata
export async function getSyncMeta(key: string): Promise<string | number | null> {
  const db = await getDB()
  const meta = await db.get('syncMeta', key)
  return meta?.value ?? null
}

export async function setSyncMeta(key: string, value: string | number): Promise<void> {
  const db = await getDB()
  await db.put('syncMeta', {
    key,
    value,
    updated_at: new Date().toISOString(),
  })
}

// Clear expired cache entries
export async function cleanupExpiredCache(): Promise<void> {
  const db = await getDB()
  const now = new Date()

  const tx = db.transaction('inspections', 'readwrite')
  const all = await tx.store.getAll()
  for (const item of all) {
    if (new Date(item.expires_at) < now) {
      await tx.store.delete(item.data.id)
    }
  }
  await tx.done
}
```
  </action>
  <verify>TypeScript compiles: cd apps/admin && npx tsc --noEmit</verify>
  <done>IndexedDB wrapper with typed stores for offline data</done>
</task>

<task type="auto">
  <name>Task 2: Create sync service and offline hook</name>
  <files>apps/admin/src/lib/offline/sync.ts, apps/admin/src/hooks/use-offline.ts</files>
  <action>
Create apps/admin/src/lib/offline/sync.ts:

```ts
import { supabase } from '@/lib/supabase'
import {
  getUnsyncedFindings,
  markFindingsSynced,
  getUnsyncedPhotos,
  markPhotoUploaded,
  setSyncMeta,
} from './db'

export interface SyncResult {
  findings_synced: number
  photos_uploaded: number
  errors: string[]
}

// Sync all pending data to server
export async function syncPendingData(): Promise<SyncResult> {
  const result: SyncResult = {
    findings_synced: 0,
    photos_uploaded: 0,
    errors: [],
  }

  if (!navigator.onLine) {
    result.errors.push('Device is offline')
    return result
  }

  // Sync photos first (findings may reference uploaded URLs)
  const photosResult = await syncPendingPhotos()
  result.photos_uploaded = photosResult.uploaded
  result.errors.push(...photosResult.errors)

  // Then sync findings
  const findingsResult = await syncPendingFindings()
  result.findings_synced = findingsResult.synced
  result.errors.push(...findingsResult.errors)

  // Update last sync timestamp
  if (result.errors.length === 0) {
    await setSyncMeta('last_sync', new Date().toISOString())
  }

  return result
}

async function syncPendingPhotos(): Promise<{ uploaded: number; errors: string[] }> {
  const photos = await getUnsyncedPhotos()
  let uploaded = 0
  const errors: string[] = []

  for (const photo of photos) {
    try {
      // Upload to Supabase Storage
      const path = `inspections/${photo.inspection_id}/${photo.item_id}/${photo.filename}`
      const { data, error } = await supabase.storage
        .from('inspection-photos')
        .upload(path, photo.blob, {
          cacheControl: '3600',
          upsert: false,
        })

      if (error) throw error

      // Get public URL
      const { data: urlData } = supabase.storage
        .from('inspection-photos')
        .getPublicUrl(path)

      await markPhotoUploaded(photo.id, urlData.publicUrl)
      uploaded++
    } catch (err) {
      errors.push(`Failed to upload photo ${photo.id}: ${err}`)
    }
  }

  return { uploaded, errors }
}

async function syncPendingFindings(): Promise<{ synced: number; errors: string[] }> {
  const findings = await getUnsyncedFindings()
  if (findings.length === 0) return { synced: 0, errors: [] }

  // Group by inspection for batch updates
  const byInspection = new Map<string, typeof findings>()
  for (const f of findings) {
    const existing = byInspection.get(f.inspection_id) || []
    existing.push(f)
    byInspection.set(f.inspection_id, existing)
  }

  let synced = 0
  const errors: string[] = []
  const syncedKeys: string[] = []

  for (const [inspectionId, items] of byInspection) {
    try {
      // Get current inspection data
      const { data: inspection, error: fetchError } = await supabase
        .from('inspections')
        .select('findings')
        .eq('id', inspectionId)
        .single()

      if (fetchError) throw fetchError

      // Merge findings
      const currentFindings = (inspection.findings || {}) as Record<string, unknown>
      const mergedFindings = { ...currentFindings }

      for (const item of items) {
        mergedFindings[item.item_id] = item.finding
        syncedKeys.push(`${inspectionId}:${item.item_id}`)
      }

      // Update inspection
      const { error: updateError } = await supabase
        .from('inspections')
        .update({
          findings: mergedFindings,
          updated_at: new Date().toISOString(),
        })
        .eq('id', inspectionId)

      if (updateError) throw updateError

      synced += items.length
    } catch (err) {
      errors.push(`Failed to sync findings for inspection ${inspectionId}: ${err}`)
    }
  }

  // Mark synced
  if (syncedKeys.length > 0) {
    await markFindingsSynced(syncedKeys)
  }

  return { synced, errors }
}

// Register for background sync (if supported)
export async function registerBackgroundSync(): Promise<boolean> {
  if (!('serviceWorker' in navigator) || !('SyncManager' in window)) {
    return false
  }

  try {
    const registration = await navigator.serviceWorker.ready
    await (registration as any).sync.register('sync-inspection-data')
    return true
  } catch (err) {
    console.warn('Background sync registration failed:', err)
    return false
  }
}
```

Create apps/admin/src/hooks/use-offline.ts:

```ts
import { useState, useEffect, useCallback } from 'react'
import { syncPendingData, registerBackgroundSync, type SyncResult } from '@/lib/offline/sync'
import { getSyncMeta, getUnsyncedFindings, getUnsyncedPhotos } from '@/lib/offline/db'

export interface OfflineState {
  isOnline: boolean
  isSyncing: boolean
  lastSyncedAt: string | null
  pendingChanges: number
  syncNow: () => Promise<SyncResult>
}

export function useOffline(): OfflineState {
  const [isOnline, setIsOnline] = useState(navigator.onLine)
  const [isSyncing, setIsSyncing] = useState(false)
  const [lastSyncedAt, setLastSyncedAt] = useState<string | null>(null)
  const [pendingChanges, setPendingChanges] = useState(0)

  // Track online/offline status
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true)
      // Auto-sync when coming back online
      syncNow()
    }
    const handleOffline = () => setIsOnline(false)

    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)

    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])

  // Load initial sync metadata
  useEffect(() => {
    const loadMeta = async () => {
      const lastSync = await getSyncMeta('last_sync')
      setLastSyncedAt(lastSync as string | null)

      const findings = await getUnsyncedFindings()
      const photos = await getUnsyncedPhotos()
      setPendingChanges(findings.length + photos.length)
    }

    loadMeta()
    // Register background sync
    registerBackgroundSync()
  }, [])

  // Manual sync trigger
  const syncNow = useCallback(async (): Promise<SyncResult> => {
    if (isSyncing || !navigator.onLine) {
      return { findings_synced: 0, photos_uploaded: 0, errors: ['Already syncing or offline'] }
    }

    setIsSyncing(true)
    try {
      const result = await syncPendingData()

      // Refresh pending count
      const findings = await getUnsyncedFindings()
      const photos = await getUnsyncedPhotos()
      setPendingChanges(findings.length + photos.length)

      // Update last synced
      const lastSync = await getSyncMeta('last_sync')
      setLastSyncedAt(lastSync as string | null)

      return result
    } finally {
      setIsSyncing(false)
    }
  }, [isSyncing])

  return {
    isOnline,
    isSyncing,
    lastSyncedAt,
    pendingChanges,
    syncNow,
  }
}

// Hook to check if specific inspection has offline changes
export function useInspectionOfflineStatus(inspectionId: string) {
  const [hasPendingChanges, setHasPendingChanges] = useState(false)

  useEffect(() => {
    const check = async () => {
      const findings = await getUnsyncedFindings()
      const photos = await getUnsyncedPhotos()
      const hasChanges =
        findings.some(f => f.inspection_id === inspectionId) ||
        photos.some(p => p.inspection_id === inspectionId)
      setHasPendingChanges(hasChanges)
    }

    check()
    // Check periodically
    const interval = setInterval(check, 5000)
    return () => clearInterval(interval)
  }, [inspectionId])

  return hasPendingChanges
}
```
  </action>
  <verify>TypeScript compiles: cd apps/admin && npx tsc --noEmit</verify>
  <done>Sync service and offline hooks provide sync queue management</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd apps/admin && npm install idb` succeeds
- [ ] `cd apps/admin && npx tsc --noEmit` passes
- [ ] IndexedDB operations work (can test in browser console)
- [ ] Sync logic properly batches updates
- [ ] Online/offline detection works
</verification>

<success_criteria>
- All tasks completed
- idb library installed
- TypeScript compiles without errors
- IndexedDB schema supports inspections, findings, photos
- Sync queue processes when online
- Background sync registered
</success_criteria>

<output>
After completion, create `.planning/phases/07-inspector-mobile/07-03-SUMMARY.md`
</output>
