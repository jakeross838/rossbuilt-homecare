---
phase: 07-inspector-mobile
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/admin/src/lib/types/inspector.ts
  - apps/admin/src/lib/constants/inspector.ts
  - apps/admin/src/hooks/use-inspector-schedule.ts
autonomous: true
must_haves:
  truths:
    - "Can fetch inspector's assigned inspections for a date"
    - "Can filter inspections by status (scheduled, in_progress)"
    - "Inspector schedule includes property and checklist details"
  artifacts:
    - path: "apps/admin/src/lib/types/inspector.ts"
      provides: "TypeScript types for inspector workflow"
    - path: "apps/admin/src/hooks/use-inspector-schedule.ts"
      provides: "React Query hooks for inspector schedule"
  key_links:
    - from: "use-inspector-schedule.ts"
      to: "inspections table"
      via: "Supabase query with inspector_id filter"
---

<objective>
Create types, constants, and hooks for inspector schedule and workflow.

Purpose: Provide the data layer for inspectors to see their daily schedule.
Output: Types and hooks for fetching inspector-specific inspection data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs
@.planning/phases/06-smart-scheduling/06-01-SUMMARY.md

# Existing types and hooks
@apps/admin/src/lib/types/scheduling.ts
@apps/admin/src/hooks/use-inspections.ts

# Database schema
@supabase/migrations/008_inspections.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create inspector types and constants</name>
  <files>apps/admin/src/lib/types/inspector.ts, apps/admin/src/lib/constants/inspector.ts</files>
  <action>
Create apps/admin/src/lib/types/inspector.ts:

```ts
import type { Enums } from '@/types/database.types'

// Inspection with full details needed for execution
export interface InspectorInspection {
  id: string
  property_id: string
  program_id: string | null
  inspection_type: string
  status: Enums<'inspection_status'> | null
  scheduled_date: string
  scheduled_time_start: string | null
  scheduled_time_end: string | null
  estimated_duration_minutes: number | null
  actual_start_at: string | null
  actual_end_at: string | null
  checklist: InspectionChecklist
  findings: Record<string, ChecklistItemFinding>
  overall_condition: Enums<'condition_rating'> | null
  summary: string | null
  weather_conditions: WeatherConditions | null
  // Joined data
  property: {
    id: string
    name: string
    address_line1: string
    address_line2: string | null
    city: string
    state: string
    zip: string
    access_codes: Record<string, string> | null
    special_instructions: string | null
  } | null
  client: {
    id: string
    first_name: string
    last_name: string
    phone: string | null
    email: string | null
  } | null
}

// Checklist structure (snapshot from template)
export interface InspectionChecklist {
  sections: ChecklistSection[]
  generated_at?: string
  template_versions?: Record<string, number>
}

export interface ChecklistSection {
  id: string
  title: string
  order: number
  items: ChecklistItem[]
}

export interface ChecklistItem {
  id: string
  label: string
  description?: string
  item_type: 'boolean' | 'numeric' | 'text' | 'photo' | 'rating' | 'select'
  required: boolean
  options?: string[] // For select type
  unit?: string // For numeric type
  min_value?: number
  max_value?: number
}

// Finding recorded for each checklist item
export interface ChecklistItemFinding {
  status: 'pass' | 'fail' | 'na' | 'needs_attention' | 'urgent'
  response?: string // Text response
  numeric_value?: number
  photos: string[]
  notes?: string
  recommendation_added?: boolean
  completed_at?: string
}

// Weather conditions at time of inspection
export interface WeatherConditions {
  temperature?: number
  humidity?: number
  conditions?: string
  wind_speed?: number
}

// Inspector's daily schedule view
export interface InspectorDaySchedule {
  date: string
  inspections: InspectorInspection[]
  total_estimated_minutes: number
}

// Inspection execution state (for offline/progress tracking)
export interface InspectionProgress {
  inspection_id: string
  started_at: string | null
  completed_items: number
  total_items: number
  pending_photos: number // Photos not yet uploaded
  is_offline: boolean
  last_synced_at: string | null
}
```

Create apps/admin/src/lib/constants/inspector.ts:

```ts
// Condition rating options with colors
export const CONDITION_RATINGS = [
  { value: 'excellent', label: 'Excellent', color: 'text-green-600', bg: 'bg-green-100' },
  { value: 'good', label: 'Good', color: 'text-blue-600', bg: 'bg-blue-100' },
  { value: 'fair', label: 'Fair', color: 'text-yellow-600', bg: 'bg-yellow-100' },
  { value: 'needs_attention', label: 'Needs Attention', color: 'text-orange-600', bg: 'bg-orange-100' },
  { value: 'poor', label: 'Poor', color: 'text-red-600', bg: 'bg-red-100' },
] as const

// Checklist item status options
export const ITEM_STATUS_OPTIONS = [
  { value: 'pass', label: 'Pass', icon: 'check', color: 'text-green-600' },
  { value: 'fail', label: 'Fail', icon: 'x', color: 'text-red-600' },
  { value: 'needs_attention', label: 'Needs Attention', icon: 'alert-triangle', color: 'text-yellow-600' },
  { value: 'urgent', label: 'Urgent', icon: 'alert-circle', color: 'text-red-600' },
  { value: 'na', label: 'N/A', icon: 'minus', color: 'text-gray-400' },
] as const

// Photo upload limits
export const PHOTO_LIMITS = {
  MAX_PHOTOS_PER_ITEM: 5,
  MAX_FILE_SIZE_MB: 10,
  ACCEPTED_TYPES: ['image/jpeg', 'image/png', 'image/webp'],
  THUMBNAIL_WIDTH: 200,
  THUMBNAIL_HEIGHT: 200,
} as const

// Offline storage keys
export const OFFLINE_STORAGE_KEYS = {
  PENDING_INSPECTIONS: 'pending_inspections',
  PENDING_PHOTOS: 'pending_photos',
  INSPECTION_PROGRESS: 'inspection_progress',
  LAST_SYNC: 'last_sync_timestamp',
} as const
```
  </action>
  <verify>TypeScript compiles: cd apps/admin && npx tsc --noEmit</verify>
  <done>Inspector types and constants defined for workflow</done>
</task>

<task type="auto">
  <name>Task 2: Create inspector schedule hooks</name>
  <files>apps/admin/src/hooks/use-inspector-schedule.ts</files>
  <action>
Create apps/admin/src/hooks/use-inspector-schedule.ts:

```ts
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { useAuthStore } from '@/stores/auth-store'
import type { InspectorInspection, InspectorDaySchedule } from '@/lib/types/inspector'

// Fetch inspector's inspections for a specific date
export function useInspectorDaySchedule(date: string) {
  const { user } = useAuthStore()
  const inspectorId = user?.id

  return useQuery({
    queryKey: ['inspector-schedule', inspectorId, date],
    queryFn: async (): Promise<InspectorDaySchedule> => {
      if (!inspectorId) {
        return { date, inspections: [], total_estimated_minutes: 0 }
      }

      const { data, error } = await supabase
        .from('inspections')
        .select(`
          id,
          property_id,
          program_id,
          inspection_type,
          status,
          scheduled_date,
          scheduled_time_start,
          scheduled_time_end,
          estimated_duration_minutes,
          actual_start_at,
          actual_end_at,
          checklist,
          findings,
          overall_condition,
          summary,
          weather_conditions,
          properties (
            id,
            name,
            address_line1,
            address_line2,
            city,
            state,
            zip,
            access_codes,
            special_instructions
          ),
          clients!properties (
            id,
            first_name,
            last_name,
            phone,
            email
          )
        `)
        .eq('inspector_id', inspectorId)
        .eq('scheduled_date', date)
        .in('status', ['scheduled', 'in_progress'])
        .order('scheduled_time_start')

      if (error) throw error

      const inspections = (data || []).map((row) => ({
        id: row.id,
        property_id: row.property_id,
        program_id: row.program_id,
        inspection_type: row.inspection_type,
        status: row.status,
        scheduled_date: row.scheduled_date,
        scheduled_time_start: row.scheduled_time_start,
        scheduled_time_end: row.scheduled_time_end,
        estimated_duration_minutes: row.estimated_duration_minutes,
        actual_start_at: row.actual_start_at,
        actual_end_at: row.actual_end_at,
        checklist: row.checklist as InspectorInspection['checklist'],
        findings: row.findings as InspectorInspection['findings'],
        overall_condition: row.overall_condition,
        summary: row.summary,
        weather_conditions: row.weather_conditions as InspectorInspection['weather_conditions'],
        property: row.properties as unknown as InspectorInspection['property'],
        client: row.clients as unknown as InspectorInspection['client'],
      })) as InspectorInspection[]

      const total_estimated_minutes = inspections.reduce(
        (sum, i) => sum + (i.estimated_duration_minutes || 60),
        0
      )

      return { date, inspections, total_estimated_minutes }
    },
    enabled: !!inspectorId && !!date,
    staleTime: 1000 * 60 * 5, // 5 minutes
  })
}

// Fetch single inspection with full details for execution
export function useInspectorInspection(inspectionId: string | undefined) {
  return useQuery({
    queryKey: ['inspector-inspection', inspectionId],
    queryFn: async (): Promise<InspectorInspection | null> => {
      if (!inspectionId) return null

      const { data, error } = await supabase
        .from('inspections')
        .select(`
          id,
          property_id,
          program_id,
          inspection_type,
          status,
          scheduled_date,
          scheduled_time_start,
          scheduled_time_end,
          estimated_duration_minutes,
          actual_start_at,
          actual_end_at,
          checklist,
          findings,
          overall_condition,
          summary,
          weather_conditions,
          properties (
            id,
            name,
            address_line1,
            address_line2,
            city,
            state,
            zip,
            access_codes,
            special_instructions
          ),
          clients!properties (
            id,
            first_name,
            last_name,
            phone,
            email
          )
        `)
        .eq('id', inspectionId)
        .single()

      if (error) {
        if (error.code === 'PGRST116') return null
        throw error
      }

      return {
        id: data.id,
        property_id: data.property_id,
        program_id: data.program_id,
        inspection_type: data.inspection_type,
        status: data.status,
        scheduled_date: data.scheduled_date,
        scheduled_time_start: data.scheduled_time_start,
        scheduled_time_end: data.scheduled_time_end,
        estimated_duration_minutes: data.estimated_duration_minutes,
        actual_start_at: data.actual_start_at,
        actual_end_at: data.actual_end_at,
        checklist: data.checklist as InspectorInspection['checklist'],
        findings: data.findings as InspectorInspection['findings'],
        overall_condition: data.overall_condition,
        summary: data.summary,
        weather_conditions: data.weather_conditions as InspectorInspection['weather_conditions'],
        property: data.properties as unknown as InspectorInspection['property'],
        client: data.clients as unknown as InspectorInspection['client'],
      }
    },
    enabled: !!inspectionId,
  })
}

// Fetch upcoming inspections for inspector (next 7 days)
export function useInspectorUpcoming() {
  const { user } = useAuthStore()
  const inspectorId = user?.id

  return useQuery({
    queryKey: ['inspector-upcoming', inspectorId],
    queryFn: async () => {
      if (!inspectorId) return []

      const today = new Date().toISOString().split('T')[0]
      const nextWeek = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]

      const { data, error } = await supabase
        .from('inspections')
        .select(`
          id,
          property_id,
          inspection_type,
          status,
          scheduled_date,
          scheduled_time_start,
          estimated_duration_minutes,
          properties (
            id,
            name,
            city
          )
        `)
        .eq('inspector_id', inspectorId)
        .gte('scheduled_date', today)
        .lte('scheduled_date', nextWeek)
        .in('status', ['scheduled', 'in_progress'])
        .order('scheduled_date')
        .order('scheduled_time_start')

      if (error) throw error
      return data
    },
    enabled: !!inspectorId,
  })
}
```

Note: The clients join uses `clients!properties` to join through the properties foreign key.
  </action>
  <verify>TypeScript compiles: cd apps/admin && npx tsc --noEmit</verify>
  <done>Inspector schedule hooks fetch daily and upcoming inspections</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd apps/admin && npx tsc --noEmit` passes
- [ ] Types exported correctly from inspector.ts
- [ ] Constants exported correctly from inspector/constants.ts
- [ ] Hooks fetch inspector-specific data with proper filtering
</verification>

<success_criteria>
- All tasks completed
- TypeScript compiles without errors
- Inspector types cover all workflow needs
- Schedule hooks filter by inspector_id
</success_criteria>

<output>
After completion, create `.planning/phases/07-inspector-mobile/07-02-SUMMARY.md`
</output>
